/set help_de=<I>pre_load>I<<II>misc>II<config_status_static, infodefiniert eine variable fuer die statuszeile sofort (on the fly). die informationen zur darstellung werden aus den konfigurationsvariablen fuer farbe und text geholt (color_sl_varname*, text_sl_varname*)@{n}wenn statt des defaultwerts der variablenname noch einmal angegeben wird, wird die variable per selbstzuweisung aktualisiert<II>comm>II<config_status<II>mak>II<set_status_var_num, set_status_var_flag, dep_var, undep_var, dset, self_update, format_number, attr_ordered, attr_ordered_cmp, status_get_quote, status_config_set_attr, status_config_attr<II>func>II<status_colors<II>version>II<status.tf,v 1.19 2002/03/27 01:21:13 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Statuszeile, die ihre Attribute selbst aendern kann<II>fileinfo>II<status.tf<II>info>II<Dieser Hook wird vor dem Laden eines Files mit dem puren Dateinamen als Parameter ausgefuehrt.<II>see>II</mload<II>type>II<hook<II>fileinfo>II<loading.tf<II><I>reload>I<<II>info>II<Dieser Hook wird zum Neuladen aller geladenen Dateien ausgefuehrt, er wird von /mload mit den bisher geladenen Dateien gefuellt. Er enthaelt z. Zt. nur Aufrufe von /mload, kann aber durch andere Kommandos ergaenzt werden, die beim Neuladen der Files notwendig werden.<II>see>II</mload<II>type>II<hook<II>fileinfo>II<loading.tf<II><I>custom>I<<II>info>II<Wertet den '-c'-Parameter der Speicher- und Ladekommandos aus und gibt das entsprechende offset directory zurueck. Ggf. muss noch das Basis-Makro Directory davorgehaengt werden (bei Speicherkommandos).<II>syn>II<-m bedeutet multiple Files der Filename ist dann ein Pattern z.B. *.tf, es wird dann die Variable load_multi auf 1 gesetzt@{N}-a erzeugt absolute Pfade, dh. vor den offset wird noch %makdir gehaengt@{N}-c nimmt ${world_host} als Offset oder, wenn ${world_host} nicht gesetzt ist, dann %default_world_host.@{N}-cp nimmt ${world_host} als Offset oder, wenn ${world_host} nicht gesetzt ist, dann %default_world_host und als zweiten Offset ${world_character} bzw. %default_world_character.@{N}-coffset nimmt offset als Offset ,)<II>opt>II<-p[char] Character@{N}-c[host] Host (Mud)@{N}-l[lang] Sprache (Language)@{N}-q quiet (ohne Meldungen)@{N}-vvarname Inhalt der Variablen (z.b. -vp_guild -> gildenbez.)@{N}-ddirname dirname uebernommen (z.b. -dnpcs -> npcs.)<II>ex>II<'-cmg.mud.de' liefert 'mg.mud.de/' als Offset fuer mudspezifische Dateien und@{N}'-c -p' liefert bei mir 'mg.mud.de/mesirii/'<II>version>II<1.02<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>mload>I<<II>info>II<Laedt ein Makrofile. Dabei kann die Endung '.tf' oder '.mak' weggelassen werden.@{N}Die geladenen Dateien werden im Hookmakro reload zum Neuladen gespeichert.Mit '/mload -c' werden die Dateien aus dem Verzeichnis ${world_host} geladen.@{N}Es wird der Hook loaded ausgefuehrt, der nach dem Laden eines Files mit dem Dateinamen (1), mit vollem Pfad(2) und mit den Ladeparametern(-2) ausgefuehrt wird. (z.B. /eval_hook loaded kampf.tf mg.mud.de/kampf/kampf.tf -c -dkampf)@{N}Wenn ein Makro dateiname_tf_init definiert ist, wird dieses nach dem Laden ausgefuehrt (load_init_config) um ggf. eine Initialisierung nach dem Fileladen zu ermoeglichen.<II>opt>II<-m bedeutet multiple Files der Filename ist dann ein Pattern z.B. *.tf, es wird pro File ein /mload aufgerufen@{N}/addh syn /mload [-q] [-p[directory]] [-c[directory]] -mfile[.tf|.mak]<II>see>II<re, purge, load, load_init_config, custom<II>mak>II<hook_reload, add_to_hook, eval_hook<II>hook>II<loaded, reload<II>changes>II</custom wurde ausgegliedert.<II>version>II<1.02<II>type>II<comm<II>fileinfo>II<loading.tf<II><I>load_init_config>I<<II>info>II<fuehrt ein Initialisierungsmakro nach dem Laden des Files aus. Der Parameter ist der Dateiname, dieser wird wie bei den file_info Variablen als Praefix vor das _init gesetzt<II>ex>II</load_init_config loading.tf -> aufruf von loading_tf_init wenn existent<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>load_config>I<<II>info>II<laedt die beiden Konfigurationsdateien name.def und name.cfg aus dem ueber die Parameter spezifizierten Verzeichnis<II>opt>II<siehe /custom<II>ex>II</load_config user_config<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>load_depend>I<<II>info>II<Laedt abhaengige Dateien fuer die, mit vollem Pfad uebergebene, Makrodatei. Dabei enthaelt dateiname.def die Standardeinstellungen und sollte nicht vom Benutzer veraendert werden, dazu ist die Kopie namens dateiname.cfg da. Bei einer Neuinstallation wird dateiname.def ueberschrieben, damit dort auch aktuelle Aenderungen (z. B. neue Konfigurationsparameter) zum Tragen kommen. In Dateiname.test kann eine Testdatei stehen.<II>syn>II</load_depend voller_dateiname<II>ex>II</load_depend loading.tf<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>file_suffixes>I<<II>info>II<Wird von /mload benutzt, um eine Datei mit verschiedenen Dateiendungen zu laden. Standardmaessig stehen die Dateiendungen in der Variablen 'file_suffixes'. Wenn das Verzeichnis nicht gegeben ist (also tf suchen soll), dann statt des Verzeichnisses einen Punkt (.) uebergeben.<II>type>II<var<II>fileinfo>II<loading.tf<II><I>try_load>I<<II>syn>II</try_load (dir|.) file possible_suffix_list<II>ex>II</try_load ~/makros loading .tf .mak<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>file_info>I<<II>info>II<Liefert die Informationen in den Dateivariablen dateiname_suffix_name.<II>ex>II</test file_info("loading_tf","version")<II>type>II<func<II>fileinfo>II<loading.tf<II><I>remove_cvs>I<<II>info>II<Entfernt die Zusatztexte vom CVS von den Id Informationen.<II>syn>II</remove_cvs Text von Id<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>get_filename_file_info>I<<II>info>II<wandelt den uebergebenen Dateinamen in eine Form um, die fuer die Dateiinfo Variablen (z.B. filename_version) nutzbar ist, dabei werden z.b. [.-] in Unterstriche _ umgewandelt und nur der Dateiname ohne Pfad genutzt<II>see>II<user_echo_file_info, echo_file_info, is_file_loaded<II>type>II<misc<II>fileinfo>II<loading.tf<II><I>echo_file_info>I<<II>info>II<Sofern 'load_quiet' nicht gesetzt ist, werden per /user_echo_file_info die Dateiinformationen der Dateivariablen ausgegeben.<II>var>II<lokal fi_filename, fi_file<II>cfg>II</user_echo_file_info<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>is_file_loaded>I<<II>info>II<testet ob das angegebene File schon geladen ist, dabei wird auf die Existenz der filename_version Variablen geprueft<II>type>II<mak<II>fileinfo>II<loading.tf<II><I>list_required>I<<II>info>II<Parst die Liste der benoetigten Files und zeigt farbig an, welche davon schon geladen sind, dabei unterschieden zwischen unbedingt notwendigen Dateien und spaeter benoetigten Dateien.@{N}In der Dateivariablen 'filename_tf_requires' stehen die benoetigten Dateien, dabei sind die unbedingt notwenigen mit einem ! als Praefix markiert.<II>cfg>II<siehe \$(/listvar -s format_attr_*)<II>var>II<fi_filename<II>type>II<func<II>fileinfo>II<loading.tf<II><I>purge_reload>I<<II>info>II<Laedt alle Makrodateien neu, ohne vorher den Speicher zu loeschen.<II>mak>II<eval_hook<II>type>II<comm<II>info>II<Loescht den Speicher und laedt alle mit bisher geladenen Makrofiles neu.@{N}Alle Variablen werden auch abgespeichert und neu geladen.<II>mak>II<hook_reload, eval_hook<II>see>II<mload, purge, load<II>type>II<comm<II>fileinfo>II<loading.tf<II><I>loading.tf>I<<II>info>II<Das Dateisystem beruht auf den Properties eines Spielers.@{N}Es gibt Dateien, die vom Mud und Spieler (in gewissen Grenzen) unabhaengig sind:@{N}?loading.tf, ?help.tf, ?lists.tf, ?untroom.tf, ?way.tf, ?properties.tf@{N}Die Datei ${world_host}/${world_character}.tf (z.B.) mg.mud.de/mesirii.tf ist vom Mud abhaengig und wird beim Connect vom tf entsprechend geladen. Ausserdem wird aus diesem Directory auch die ?customize.tf geladen, die viele Einstellungen enthaelt.@{N}Zu den Dateien bitte die dortigen Hilfeseiten anschauen. Und jetzt viel Spass.<II>see>II<loading.tf, help.tf, lists.tf, untroom.tf, way.tf, properties.tf, customize.tf, mesirii.tf, chaos.tf, ueben.tf<II>changes>II<1.01 In den Hook Kommandos wurden Ueberpruefungen eingebaut, ob die Hooks schon existieren.@{N}/mload ruft jetzt den Hook pre_load vor dem Laden eines Files und loaded nach dem Laden eines Files auf.@{N}1.02 Das Laden von -c (=custom) Dateien wurde aus /mload ausgelagert, so dass alle Funktionen es nutzen koennen (siehe /custom).@{N}1.04 /custom wurde um die Moeglichkeit ergaenzt, -cp als einzigen Parameter zum Laden anzugeben; damit wird and das Mudverzeichnis noch ein Playerverzeichnis zum Laden drangehaengt.@{N}Fehler in myconn (CONNECT) behoben, der mehrfaches Laden der Files zur Folge hatte.<II>misc>II<get_filename_file_info<II>comm>II<mload, reload, purge_reload<II>mak>II<custom, load_init_config, load_config, load_depend, try_load, remove_cvs, echo_file_info, is_file_loaded<II>hook>II<pre_load, reload<II>func>II<file_info, list_required<II>var>II<file_suffixes<II>version>II<loading.tf,v 1.35 2002/03/27 01:36:41 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf util.hooks.tf util.prompts.tf<II>type>II<fileinfo<II>fileinfo>II<loading.tf<II><I>sshload>I<<II>info>II<laedt ein file ueber eine ssh verbindung, dabei werden innerhalb des Files die Kommandos /cd, /load und /exit beruecksichtigt. Alles andere wird ausgefuehrt (Makrodefinitionen, Code im File)<II>syn>II</sshload host path/file<II>ex>II</sshload server.home.net TinyMacros/private.tf<II>type>II<comm<II>fileinfo>II<sshload.tf<II><I>sreplace>I<<II>fileinfo>II<<II>info>II<Ersetzt Parameter1 durch Parameter2 im String, der als restlicher Parameter angegeben ist. Das Ergebnis wird mit /result zurueckgegeben, also ueber $() holen. Dabei koennen Parameter1 bzw. Parameter2 auch \space fuer Leerzeichen sein.<II>syn>II</sreplace (suchtext|\space) (ersetztext|\space) string<II>ex>II</sreplace beutel paket oeffne beutel@{N}wuerde "oeffne paket" zurueckgeben.<II>return>II<ueber /result den veraenderten String<II>see>II<substitution<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>paramparse>I<<II>info>II<Erlaubt einen anderen Parameterseparator als das Leerzeichen. Dabei werden /paramparse als Parameter1 der Separator, als Parameter2 die gewuenschte Position (1,2,3 oder  -1,-2,-3...) und als Rest die Parameter uebergeben.@{N}Achtung, /paramparse verwendet regmatch(), d.h. %P1 etc. aendern ihre Werte!<II>return>II<ueber /return<II>syn>II</paramparse Separator [-](1,2,3..) Parameter<II>ex>II<Nach@{N}@{}  /set a=$[paramparse("&",3,"Das hier&ist aber& ein bloe&des Beispiel")]@{N}@{}  /set b=$(/paramparse & -2 Das hier&ist aber& ein bloe&des Beispiel)@{N}haette a den Wert ' ein bloe' und b ' ein bloe&des Beispiel'.<II>see>II<substitution, regexp<II>type>II<func<II>fileinfo>II<lists.tf<II><I>islist>I<<II>info>II<Liefert einen Wert ungleich %error zurueck, wenn die uebergebene Variable dem Anschein nach eine Liste ist, also mit <I@{}> beginnt und endet.<II>syn>II</isList listenname<II>ex>II</if (isList("demo_list") =~ error) ...@{N}oder@{N}/isList demo_list@{N}/if (value =~ error) ...<II>return>II<%error bei Fehler als Rueckgabewert und in %value.<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>sortforeach>I<<II>info>II<Hat die gleiche Funktionalitaet wie /forEach, die Werte werden aber alphabetisch sortiert bearbeitet.<II>syn>II</sortForEach listenname k[v] /makroname<II>var>II<%value<II>see>II</forEach<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>hsortforeach>I<<II>info>II<Hat die gleiche Funktionalitaet wie /hforEach (also fuer Hashlisten), die Werte werden aber alphabetisch sortiert bearbeitet.<II>syn>II</hsortForEach listenname k[v] /makroname<II>var>II<%value<II>see>II</hforEach<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>hashliste>I<<II>info>II<Hashlisten basieren darauf, dass tf-Variablen beliebig zur Laufzeit erzeugt werden koennen. Fuer jeden Schluessel in der Liste wird der Hashwert (siehe /hash) gebildet und dieser an eine Variable mit dem Namen der Liste angehaengt (z.B. 'weapons___329874923'). In dieser Variablen wird nun eine normale Liste aller Schluessel-Wert-Paare gespeichert, deren Schluessel denselben Hashcode erzeugen. Der Zugriff auf die TF-Variablen ist um ein Vielfaches schneller als die Arbeit mit riesigen Strings.<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>hashlist>I<<II>info>II<Wandelt eine normale Liste in eine ?Hashliste um.<II>syn>II</hashlist listenname<II>var>II<%value<II>mak>II</getfirstkey, /getfirstvalue, /haddtolist, /deletekeyandvalue<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>removehashed>I<<II>info>II<Wandelt eine ?Hashliste wieder in eine normale Liste um, das kann ggf. dauern ;)<II>syn>II</removehashed listenname<II>var>II<%value<II>mak>II</tokenize<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hxaddtolist>I<<II>info>II<Fuegt ein Schluessel-Wert-Paar zu einer ?Hashliste hinzu. Dabei kann der Schluessel auch mehrteilig sein, Trennung der Parameter durch '&'.<II>syn>II</hxaddtolist listenname&schl ues sel&wert<II>see>II</haddtolist<II>var>II<%value<II>mak>II</paramparse<II>func>II<hash<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>haddtolist>I<<II>info>II<Fuegt ein Schluessel-Wert-Paar zu einer ?Hashliste hinzu. Dabei darf der Schluessel keine Leerzeichen enthalten.<II>syn>II</haddtolist listenname schluessel wert<II>var>II<%value<II>func>II<hash<II>see>II</hxaddtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hforeach>I<<II>info>II<Wie /forEach fuer normale Listen, arbeitet /hforEach eine ?Hashliste durch. Dabei ist jedoch nicht wie bei /forEach eine Reihenfolge garantiert. Die Schluessel und/oder Werte werden dem angegebenen Makro als Parameter uebergeben.<II>syn>II</hforEach listenname k[v] /makroname<II>see>II</forEach<II>ex>II</hforeach demo_list k /echo Schluessel:@{N}wuerde nacheinander alle Schluessel von 'demo_list' ausgeben<II>mak>II</forEach<II>var>II<%value<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>haddlisttosave>I<<II>info>II<Verwaltet die aktuell geladenen Hashlisten in einer eigenen Liste, damit sie bei Aenderungen durch /saveall oder /savealllists gespeichert werden.<II>ex>II</haddlisttosave listenname<II>see>II</hsavelist, /hloadlist, /hashliste, /saveall<II>mak>II</deletekeyandvalue, /addtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hcreatelist>I<<II>info>II<Erzeugt eine ?Hashliste, d.h. es werden alle Eintraege mit diesem Listennamen geloescht.<II>syn>II</hcreatelist listenname<II>see>II</createlist, Hashliste<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hcopylist>I<<II>info>II<Erstellt eine Kopie der angegebenen ?Hashliste.<II>syn>II</hcopylist quelllistenname ziellistenname<II>mak>II</hcreatelist, /hcopylist2<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hloadlist>I<<II>info>II<Analog zu /loadlist fuer normale Listen werden mit /hloadlist ?Hashlisten geladen. Die Dateien heissen 'listenname.hlist'. Es koennen alle von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Laden ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</hloadlist [/custom-Optionen] listenname<II>see>II</hsavelist, /loadlist, /custom, Hashliste<II>mak>II</custom, /ifecho, /haddlisttosave<II>var>II<%load_dir<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hsavelist>I<<II>info>II<Wie /savelist fuer normale Listen speichert /hsavelist ?Hashlisten ab. Die Dateien heissen 'listenname.hlist'. Es koennen alle von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Speichern ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</hsavelist [/custom-Optionen] listenname<II>see>II</hloadlist, /savelist, /custom, Hashliste<II>mak>II</custom, /hsavelist2, /addtolist, /deletekeyandvalue, /getvalueof, /ifecho<II>var>II<%value, %temp_handle, %hsavelen<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>result anzahl der eintraege als rueckgabewert>I<<II>info>II<Liefert die Anzahl der Schluessel in der angegebenen ?Hashliste zurueck.<II>syn>II</hcount_entries listenname<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>hcount_entries>I<<II>see>II</count_entries, Hashliste<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>hgetvalueof>I<<II>info>II<Wie /getvalueof fuer normale Listen liefert es den zum angegebenen Schluessel gehoerenden Wert bei ?Hashlisten.<II>syn>II</hgetvalueof listenname schluessel<II>return>II<zugehoeriger Wert als Rueckgabewert und in %value<II>see>II</getvalueof, Hashliste, /getkeyofvalue<II>var>II<%value, %hvalue<II>func>II<hash<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hdelallkeysandvalues>I<<II>info>II<Loescht alle Schluesseleintraege dieses Schluessels in der angegebenen ?Hashliste.<II>syn>II</hdelallkeysandvalues listenname schluessel<II>mak>II</hdeletekeyandvalue<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hdeletekeyandvalue>I<<II>info>II<Loescht den ersten Schluesseleintrag dieses Schluessels in der angegebenen ?Hashliste.<II>syn>II</hdeletekeyandvalue listenname schluessel<II>mak>II</deletekeyandvalue<II>var>II<%hvalue, %value<II>func>II<hash<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hgetdvalueof>I<<II>info>II<Liefert den ersten Wert, der mit dem angegebenen Schluessel in der ?Hashliste eingetragen ist, und loescht diesen Eintrag. Gut zum Durcharbeiten der Liste geeignet.@{N}Rueckgabe in %value und als return-Wert.<II>syn>II</hgetdvalueof listenname schluessel<II>see>II</getdvalueof, /hgetvalueof<II>mak>II</getdvalueof<II>var>II<%value<II>func>II<hash<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hgetlistvalueof>I<<II>info>II<Liefert den Wert des angegebenen Schluessels als Liste zurueck. D.h. wenn er vorher mit /haddlisttolist hinzugefuegt wurde, ist es notwendig, dies rueckgaengig zu machen. Die Ergebnisliste ist eine normale Liste. Sie kann mit@{N}/set listenname=%value@{N}oder@{N}/set listenname=$[hgetlistvalueof(...)]@{N}gesichert werden.<II>syn>II</hgetlistvalueof listenname schluessel<II>ex>II<Die Zeilen@{N}@{}   /hgetlistvalueof waffen_list schwerter@{N}@{}   /set schwerter_list=%value@{N}und@{N}@{}   /set schwerter_list=$[hgetlistvalueof("waffen_list","schwerter")]@{N}speichern beide die Subliste 'schwerter' der Hashliste 'waffen_list' in der Variablen 'schwerter_list'.<II>see>II</hgetvalueof, /getlistvalueof, /haddlisttolist, /hxaddlisttolist<II>mak>II</hgetvalueof, /unmakesub<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>haddlisttolist>I<<II>info>II<Fuegt die als Wert (%variable) angebebene Liste unter dem angegebenen Schluessel zur ?Hashliste hinzu. Dabei wird die Liste modifiziert, um als Subliste innerhalb der eigentlichen Liste erhalten zu bleiben.<II>see>II</hgetlistvalueof, /addlisttolist, /makesub, /unmakesub, /hxaddlisttolist<II>syn>II</haddlisttolist listenname schluessel wertliste<II>mak>II</haddtolist, /makesub<II>var>II<%value<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>hxaddlisttolist>I<<II>info>II<Fuegt die als Wert (%variable) angebebene Liste unter dem angegebenen Schluessel zur ?Hashliste hinzu. Dabei wird die Liste modifiziert, um als Subliste innerhalb der eigentlichen Liste erhalten zu bleiben. Damit der Schluessel auch Leerzeichen enthalten kann, muessen die Parameter durch '&' getrennt werden.<II>see>II</hgetlistvalueof, /addlisttolist, /makesub, /unmakesub, /haddlisttolist<II>syn>II</hxaddlisttolist listenname&schl ues sel&wertliste<II>mak>II</paramparse, /makesub<II>var>II<%value<II>func>II<hash<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hgetentrylist>I<<II>info>II<Liefert eine Liste zurueck, in der alle Eintraege mit dem angegebenen Schluessel gesammelt sind.<II>syn>II</hgetentrylist listenname schluessel<II>return>II<in %value und pre /return eine normale Liste der Eintraege und Werte<II>mak>II</createlist, /getdvalueof, /xaddtolist<II>func>II<hash<II>var>II<%value, %hvalue<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>felder>I<<II>info>II<Die Felder sind einfach eine Abbildung auf TF-Variablen, in denen dann die Inhalte stehen. Dabei wird der Variablenname wie folgt zusammengesetzt: 'array_feldname___index'. Die hoechsten und niedrigsten Indizes stehen in 'array_feldname___maxlen' und '*___minlen', werden aber auch von /alen und /astart geliefert.<II>see>II</aget, /aput, /ashow, /asshow, /asort, /amsort, /aforEach, alen, astart, /aclear<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>aget>I<<II>info>II<Liefert den Wert des Feldes am angegebenen Index zurueck.<II>syn>II</aget feldname index<II>return>II<Wert in %value und als Rueckgabewert<II>see>II</aput<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>aput>I<<II>info>II<Setzt den Wert des Feldes am angegebenen Index.<II>syn>II</aput feldname index wert<II>func>II<astart, alen<II>see>II</aget<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>aclear>I<<II>info>II<Loescht die Variablen, die das angegebene Feld ausmachen, und setzt die min/max Indizes neu.<II>syn>II</aclear feldname<II>see>II<alen, astart<II>mak>II</purge_vars<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>alen>I<<II>info>II<Liefert den hoechsten Index des angegebenen Feldes zurueck.<II>syn>II</alen feldname<II>return>II<Index als Rueckgabewert<II>see>II<astart<II>type>II<func<II>fileinfo>II<lists.tf<II><I>astart>I<<II>info>II<Liefert den hoechsten Index des angegebenen Feldes zurueck.<II>syn>II</astart feldname<II>return>II<Index als Rueckgabewert<II>see>II<alen<II>type>II<func<II>fileinfo>II<lists.tf<II><I>ashow>I<<II>info>II<Zeigt die Variablen an, die das angegebene Feld ausmachen.<II>syn>II</ashow feldname<II>see>II</asshow<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>asshow>I<<II>info>II<Zeigt nur die Werte an, die das angegebene Feld ausmachen.<II>syn>II</asshow feldname<II>return>II<Werte mit /result<II>see>II</ashow<II>func>II<start<II>mak>II</aget<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>aswap>I<<II>info>II<Tauscht die Feldwerte an den angegebenen Indizes aus.<II>syn>II</aswap feldname index1 index2<II>see>II</asort<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>ascmp>I<<II>info>II<Vergleichsfunktion auf Stringbasis. Liefert einen Wert < 0, wenn der Feldwert an 'index1' lexikalisch kleiner ist als an 'index2'. Bei Gleichheit wird 0 zurueckgegeben, ansonste ein positiver Wert.<II>return>II<in %value und als Rueckgabewert<II>see>II<asicmp, ancmp, strcmp<II>syn>II</ascmp feldname index1 index2<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>asicmp>I<<II>info>II<Vergleichsfunktion auf Stringbasis ohne Beruecksichtigung der Gross-/Kleinschreibung. Liefert einen Wert < 0, wenn der Feldwert an 'index1' lexikalisch kleiner ist als an 'index2'. Bei Gleichheit wird 0 zurueckgegeben, ansonste ein positiver Wert.<II>return>II<in %value und als Rueckgabewert<II>see>II<ascmp, ancmp, sctrmp<II>syn>II</asicmp feldname index1 index2<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>ancmp>I<<II>info>II<Vergleichsfunktion auf numerischer Basis. Liefert einen Wert < 0, wenn der Feldwert an 'index1' kleiner ist als an 'index2'. Bei Gleichheit wird 0 zurueckgegeben, ansonste ein positiver Wert.<II>return>II<in %value und als Rueckgabewert<II>see>II<asicmp, ascmp<II>syn>II</ancmp feldname index1 index2<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>result das sortierte feld in %amsort_base und das ggf. mitzusortierende zweite feld in %amsort_base2.>I<<II>info>II<Implementation von Merge-Sort fuer die Felder. Es werden das zu sortierende Feld, minIndex und maxIndex sowie der Name der Vergleichsfunktion uebergeben. Ausserdem ist es moeglich, ein Feld anzugeben, das in derselben Weise wie das Sortierfeld mitgetauscht wird. Als Vergleichsfunktionen kommen in erster Linie ascmp, asicmp (Default) und ancmp in Frage.<II>syn>II</amsort feldname von bis [sortierfunc] [zweitfeld]<II>ex>II</amsort baeume 4 10 ascmp obst<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>amsort>I<<II>see>II</amsort1, asicmp, ascmp, ancmp<II>var>II<%amsort_base = Sortierfeld, %amsort_func = Sortierfunktion, %amsort_base2 ggf. Zweitfeld<II>mak>II</aclear, /amsort1<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>amsort1>I<<II>info>II<Eigentliche Implementation des Merge-Sort-Algorithmus. Wird rekursiv aufgerufen. Das zu sortierende Feld steht in %amsort_base, das ggf. mitzusortierende Fehld in %amsort_base2 und die Vergleichsfunktion in %amsort_func<II>syn>II</amsort1 von bis<II>var>II<%amsort_base = Sortierfeld, %amsort_func = Vergleichsfunktion, %amsort_base2 ggf. Zweitfeld<II>mak>II</aput<II>func>II<aget<II>see>II</amsort<II>var>II<%value<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>asort>I<<II>info>II<Quick-Sort-Implementation fuer die Felder. Es werden das zu sortierende Feld, minIndex und maxIndex sowie der Name der Vergleichsfunktion uebergeben. Ausserdem ist es moeglich, ein Feld anzugeben, das in der selben Weise wie das Sortierfeld mitgetauscht wird. Als Vergleichsfunktionen kommen in erster Linie ascmp, asicmp (Default) und ancmp in Frage.<II>syn>II</asort feldname von bis [vergleichsfunktion] [zweitfeld]<II>ex>II</asort baeume 4 10 ascmp obst<II>see>II</amsort, asicmp, ascmp, ancmp<II>mak>II</aswap<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>aforeach>I<<II>info>II<Wie /forEach bzw. /hforEach fuer Listen arbeitet /aforEach alle Elemente eines Feldes durch, indem sie als Parameter fuer das uebergebene Makro genutzt werden.<II>syn>II</aforEach feldname /makroname<II>ex>II</aforEach baeume /ernte<II>func>II<astart, alen, aget<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>aforeach2>I<<II>info>II<Wie /forEach bzw. /hforEach fuer Listen arbeitet /aforEach2 alle Elemente zweier Felder durch, indem sie als Parameter fuer das uebergebene Makro genutzt werden.<II>ex>II</aforEach2 feldname feldname2 /makroname<II>func>II<astart, alen, aget<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>asortforeach>I<<II>info>II<Erfuellt dieselbe Funktion wie /forEach fuer Listen, nur dass die Elemente sortiert bearbeitet werden. Dabei kann in der Variablen %sort_alg (moeglichst als lokale Variable) der Sortieralgorithmus eingestellt werden ('asort' oder 'amsort'), sowie in der Variablen %comp_func die Vergleichsfunktion ('asicmp', 'ascmp', 'ancmp').<II>syn>II</asortForEach listenname k[v] /makroname<II>var>II<%sort_alg, %comp_func<II>mak>II</aclear, /forEach, /aforEach, /asortForEach2, /asortForEach3<II>func>II<astart, alen<II>var>II<%sort_alg, %comp_func<II>see>II</forEach, /asort, /amsort, asicmp, ascmp, ancmp<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hasortforeach>I<<II>info>II<Erfuellt dieselbe Funktion wie /hforEach fuer Hashlisten, nur dass die Elemente sortiert bearbeitet werden. Dabei kann in der Variablen %sort_alg (moeglichst als lokale Var) der Sortieralgorithmus eingestellt werden ('asort' oder 'amsort'), sowie in der Variablen %comp_func die Vergleichsfunktion ('asicmp', 'ascmp', 'ancmp').<II>ex>II</hasortForEach listenname k[v] /makroname<II>see>II</hforEach, asort, amsort, asicmp, ascmp, ancmp, /asortForEach<II>var>II<%sort_alg, %comp_func<II>mak>II</aclear, /hforEach, /aput, /asortForEach2, /asortForEach3<II>func>II<astart, alen<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>split_list>I<<II>info>II<Die angegebenen Schluessel werden aus der als ersten Parameter angegebenen Lister geloescht und mit ihren Werten in die Liste 'split_list' eingetragen.@{N}Die Schluessel duerfen keine Leerzeichen enthalten.<II>mak>II</createlist, /getdvalueof, /addhtolist<II>var>II<%split_list, %value<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>merge_lists>I<<II>info>II<Fuegt zwei Listen zusammen, wobei Schluessel, die in beiden Listen vorkommen, aus der zuerst angegebenen genommen werden. Die Ergebnisliste heisst 'merge_list'.<II>return>II<Ergebnisliste in %merge_list<II>syn>II</merge_lists listenname1 listenname2<II>see>II</hmerge_lists<II>var>II<%merge_list, %merge_list2, %value<II>mak>II</getfirstkey, /xaddtolist, /getdvalueof, /deletekeyandvalue<II>func>II<iskey<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>umerge_lists2>I<<II>info>II<Kopiert in Inhalt der ersten in die zweite Liste, wobei je nach drittem Parameter (kv) Schluessel und/oder Werte kopiert werden. Dabei werden schon vorhandene Schluessel ueberschrieben.@{N}Die Schluessel der ersten Liste duerfen keine Leerzeichen enthalten.<II>syn>II</umerge_lists2 quelllistenname zielllistenname k[v]<II>ex>II</umerge_lists2 katzen tiere kv<II>mak>II</forEach, /uaddtolist<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>hmerge_lists>I<<II>info>II<Fuegt zwei Hashlisten zusammen, wobei Schluessel, die in beiden Listen vorkommen, aus der zuerst angegebenen genommen werden. Die Ergebnisliste heisst 'hmerge_list'.<II>return>II<Ergebnisliste %hmerge_list<II>syn>II</hmerge_lists listenname1 listenname2<II>var>II<%merge_lists, %value<II>mak>II</hcopyList, /hforeEach, /hmerge_lists2<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>createlist>I<<II>info>II<Erstellt eine leere Liste. Diese Liste wird in der globalen Variable mit dem angegebenen Namen gehalten. Eine evtl. vorhandene Liste mit dem gleichen Namen wird geloescht.<II>syn>II</createlist listenname<II>see>II</createnewlist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>createnewlist>I<<II>info>II<Erzeugt eine neue Liste, wenn die Liste noch nicht existiert<II>syn>II</createlist listenname<II>see>II</createlist<II>func>II<isList<II>mak>II</createlist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>xaddbtolist>I<<II>info>II<Fuegt einen Schluessel, in dem auch Leerzeichen enthalten sein koennen, und einen Wert, die durch ein kaufmaennisches UND ('&') getrennt sind, an den Anfang einer Liste ein. Schluessel oder Wert duerfen allerdings nicht mit einem Leerzeichen enden.<II>syn>II</xaddbtolist listenname&schluessel&wert<II>ex>II</xaddbtolist fruechte&reife Aepfel&10 Stueck<II>mak>II</paramparse<II>see>II</addbtolist, /xaddtolist, /xuaddtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>xaddtolist>I<<II>info>II<Fuegt einen Schluessel, in dem auch Leerzeichen enthalten sein koennen, und einen Wert, die durch ein kaufmaennisches UND ('&') getrennt sind, am Ende einer Liste ein. Schluessel oder Wert duerfen allerdings nicht mit einem Leerzeichen enden.<II>syn>II</xaddtolist listenname&schluessel&wert<II>ex>II</xaddtolist fruechte&faule Birnen&8 Stueck<II>mak>II</paramparse<II>see>II</addtolist, /xaddbtolist, /xuaddtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>xuaddtolist>I<<II>info>II<Fuegt einen Schluessel, in dem auch Leerzeichen enthalten sein koennen, und einen Wert, die durch ein kaufmaennisches UND ('&') getrennt sind, am Ende einer Liste ein, nachdem alle bisherigen Vorkommen des Schluessels geloescht wurden. Schluessel oder Wert duerfen allerdings nicht mit einem Leerzeichen enden oder beginnen.<II>syn>II</xuaddtolist listenname&schluessel&wert<II>ex>II</xuaddtolist fruechte&faule Birnen&8 Stueck<II>mak>II</paramparse, /delallkeysandvalues<II>see>II</uaddtolist, /xaddtolist, /xaddbtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>addtolist>I<<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und einen Wert an das Ende einer Liste an.<II>syn>II</addtolist listenname schluessel wert<II>see>II</addbtolist, /xaddtolist, /uaddtolist, /getvalueof<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>uaddtolist>I<<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und einen Wert an das Ende einer Liste an, nachdem alle bisherigen Vorkommen des Schluessels geloescht wurden.<II>syn>II</uaddtolist listenname schluessel wert<II>see>II</addtolist, /addbtolist, /xuaddtolist, /getvalueof<II>mak>II</deleteallkeysandvalues, /addtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>addbtolist>I<<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und einen Wert am Anfang einer Liste ein.<II>syn>II</addbtolist listenname schluessel wert<II>see>II</addtolist, /xaddbtolist, /getvalueof<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>addlisttolist>I<<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und eine (Sub)Liste am Ende einer Liste an.@{N}In der Subliste werden die Listentrenner um eine Stufe erweitert.<II>syn>II</addlisttolist listenname schluessel subliste (der Inhalt!)<II>ex>II</addlisttolist obst aepfel %apfelsorten<II>see>II</addtolist, /getlistvalueof<II>mak>II</makesub, /addtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>uaddlisttolist>I<<II>info>II<Fuegt einen Schluessel (ohne Leerzeichen) und eine (Sub)Liste am Ende einer Liste an.@{N}In der Subliste werden die Listentrenner um eine Stufe verringert.<II>syn>II</uaddlisttolist listenname schluessel subliste (der Inhalt!)<II>ex>II</uaddlisttolist obst aepfel %apfelsorten<II>see>II</addlisttolist, /uaddtolist, /getlistvalueof<II>mak>II</unmakesub, /uaddtolist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>xaddlisttolist>I<<II>info>II<Fuegt einen Schluessel und eine (Sub)Liste am Ende einer Liste an. Dabei kann der Schluessel Leerzeichen enthalten. Die einzelnen Parameter muessen durch das Trennzeichen kaufmaennisches UND ('&') getrennt sein.@{N}In der Subliste werden die Listentrenner um eine Stufe erweitert.<II>syn>II</xaddlisttolist listenname&schluessel&subliste (der Inhalt!)<II>ex>II</xaddlisttolist rezepte&ohne Fleisch&%puddings<II>see>II</xaddtolist, /addlisttolist, /getlistvalueof<II>mak>II</paramparse, /makesub<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>foreach>I<<II>info>II<Fuehrt fuer jedes Paar der Liste das angegebene Makro mit den entsprechenden Parametern (Schluessel und/oder Wert) aus. Der zweite Parameter sagt aus, was dem Makro uebergeben wird (key|value|key value).<II>syn>II</forEach listenname (k|v|kv) /makro<II>ex>II</forEach freunde k /finger<II>var>II<%fetemp_list, %value, %break_forEach<II>mak>II</getfirstkey, /deletekeyandvalue<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>reggetvalueof>I<<II>info>II<Wie /getvalueof nur, dass der Schluessel als regexp angegeben wird (ohne Klammern rundherum).@{N}Die regexp kann am Anfang und/oder Ende mit '^' bzw. '$' verankert werden. Um zu verhindern, dass ein abschliessendes '$' als Endekennzeichen aufgefasst wird, muss dieses verdoppelt werden. ('$' muss natuerlich ggf. mit '\' maskiert werden.)<II>syn>II</reggetvalueof listenname Schluessel (als regexp)<II>ex>II<Die regexp von@{N}@{}  /reggetvalueof fruechte [a-z]*nue?sse?@{N}wuerde auf "walnuss", "haselnuesse" und "nussknacker" passen. Sollen nur Nussarten gefunden werden, muesste man@{N}@{}  /reggetvalueof fruechte [a-z]*nue?sse?\$@{N}verwenden.@{N}@{}  /reggetvalueof waehrungen ^(US|us)-\\\$\$@{N}wuerde nur den Wert der Schluessel "US-$" oder "us-$" zurueckgeben.<II>return>II<erster zum Schluessel passender Wert als Rueckgabewert und in %value, %error bei Misserfolg<II>var>II<%value<II>see>II</convert_regexp, /getvalueof, regexp, /reggetkey<II>func>II<convert_regexp<II>type>II<func<II>fileinfo>II<lists.tf<II><I>convert_regexp>I<<II>info>II<Konvertiert eine uebergebene regexp so, dass mit ihr innerhalb von Listen gesucht werden kann. Der erste Parameter gibt an, ob die regexp auf einen Schluessel ('k') oder einen Wert ('v') passen soll. Die regexp kann am Anfang und/oder Ende mit '^' bzw. '$' verankert werden. Um zu verhindern, dass ein abschliessendes '$' als Endekennzeichen aufgefasst wird, muss dieses verdoppelt werden. ('$' muss natuerlich ggf. mit '\' maskiert werden.)<II>syn>II</convert_regexp k|v regexp<II>return>II<die konvertierte regexp als Rueckgabewert mit /result<II>ex>II</let reg=$[convert_regexp("k", "^(K|k)ette")@{N}wuerde in %reg eine regexp speichern, die auf alle Schluessel passt, welche mit "Kette" oder "kette" beginnen. Durch@{N}@{}  /let reg=$(/convert_regexp v ([uU]s-|kanadische )\\\$\$@{N}wuerde auf alle Werte passen, welche mit "kanadische $", "us-$" oder "Us-$" enden.<II>see>II</reggetkey, /reggetvalue, /reggetvalueof, regexp<II>type>II<func<II>fileinfo>II<lists.tf<II><I>reggetkey>I<<II>info>II<Es wird der erste Schluessel geliefert, auf den die uebergebene regexp passt.<II>syn>II</reggetkey listenname regexp<II>return>II<erster zum Wert passender Schluessel als Rueckgabewert und in %value<II>see>II</convert_regexp, /getkeyofvalue, regexp, /reggetvalueof<II>var>II<%value<II>func>II<convert_regexp<II>type>II<func<II>fileinfo>II<lists.tf<II><I>reggetkeyofvalue>I<<II>info>II<Wie /getkeyofvalue nur, dass der Wert als regexp angegeben ist (ohne Klammern rundherum).<II>syn>II</reggetkey listenname regexp<II>return>II<erster zum Wert passender Schluessel als Rueckgabewert und in %value, %error bei Misserfolg<II>see>II</convert_regexp, /reggetkeyofvalue, regexp, /reggetvalueof<II>func>II<convert_regexp<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>reggetvalue>I<<II>info>II<Liefert den ersten Wert zurueck, auf den die regexp passt.<II>syn>II</reggetvalue listenname regexp<II>return>II<erster zur regexp passender Wert als Rueckgabewert und in %value<II>see>II</convert_regexp, regexp<II>func>II<convert_regexp<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getidxofvalue>I<<II>info>II<Liefert den Index eines Wertes innerhalb einer Liste. Die Zaehlung beginnt bei 0. Das Ergebnis wird zurueckgegeben und in %value gespeichert. Ist der Wert nicht in der Liste, so ist das Ergebnis %error. Ist der Wert mehrmals in der Liste, wird der kleinste passende Index zurueckgegeben.<II>syn>II</getidxofvalue liste|listenname wert<II>ex>II<Sowohl@{N}@{}  /test index:=getidxofvalue("skills_list","miserabel")@{N}als auch@{N}@{}  /test index:=getidxofvalue(skills_list,"miserabel")@{N}liefern den gleichen Wert.<II>return>II<Index oder %error als Rueckgabewert und in %value.<II>func>II<count_entries, isVar<II>var>II<%value<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getidxofkey>I<<II>info>II<Liefert den Index eines Schluessels innerhalb einer Liste. Die Zaehlung beginnt bei 0. Das Ergebnis wird zurueckgegeben und in %value gespeichert. Ist der Schluessel nicht in der Liste, so ist das Ergebnis %error. Ist der Schluessel mehrmals in der Liste, wird der kleinste passende Index zurueckgegeben.@{N}/addh syn /getidxofkey liste|listenname schluessel<II>ex>II<Sowohl@{N}@{}  /test index:=getidxofvalue("skills_list","50%")@{N}als auch@{N}@{}  /test index:=getidxofvalue(skills_list,"50%")@{N}liefern den gleichen Wert.<II>return>II<Index oder %error als Rueckgabewert und in %value.<II>func>II<count_entries, isVar<II>var>II<%value<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>type>II<func<II>fileinfo>II<lists.tf<II><I>reggetidxofvalue>I<<II>info>II<Liefert den Index des ersten Wertes zurueck, auf den die regexp passt.@{N}Die Liste kann sowohl direkt als auch ueber ihren Namen angegeben werden (siehe Beispiel).<II>syn>II</reggetidxofvalue listen|listenname regexp<II>return>II<Index des ersten zur regexp passenden Wertes oder %error als Rueckgabewert und in %value<II>see>II<regexp, /reggetidxofkey, /getikey, /getivalue<II>ex>II<Sowohl@{N}@{}  /test index:=reggetidxofvalue("skills_list","5[0-9]%")@{N}als auch@{N}@{}  /test index:=reggetidxofvalue(skills_list,"5[0-9]%")@{N}liefern den gleichen Wert.<II>func>II<count_entries, isVar<II>var>II<%value<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>type>II<func<II>fileinfo>II<lists.tf<II><I>reggetidxofkey>I<<II>info>II<Liefert den Index des ersten Schluessels zurueck, auf den die regexp passt.@{N}Die Liste kann sowohl direkt als auch ueber ihren Namen angegeben werden (siehe Beispiel).<II>syn>II</reggetidxofkey liste|listenname regexp<II>return>II<Index des ersten zur regexp passenden Schluessels oder %error als Rueckgabewert und in %value<II>ex>II<Sowohl@{N}@{}  /test index:=reggetidxofkey("skills_list",".* miserabel(st)?%")@{N}als auch@{N}@{}  /test index:=reggetidxofkey(skills_list,".* miserabel(st)?")@{N}liefern den gleichen Wert.<II>see>II<regexp, /getidxofvalue, /getikey, /getivalue<II>func>II<count_entries, isVar<II>var>II<%value<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getvalueof>I<<II>info>II<Liefert den ersten Wert mit diesem Schluessel zurueck.<II>syn>II</getvalueof listenname schluessel<II>return>II<erster zum Schluessel passender Wert oder %error bei Fehler als Rueckgabewert und in %value<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getnextvalueof>I<<II>info>II<Liefert bei aufeinanderfolgenden Aufrufen die verschiedenen Werte, die zu einem Schluessel in der Liste gespeichert sind.<II>syn>II</getnextvalueof listenname schluessel<II>return>II<der Wert zu diesem Schluessel oder %error, wenn keine (mehr) vorhanden sind, als Rueckgabewert und in %value<II>var>II<%value, %getnextvalueof, %getnextvalueof_off<II>type>II<func<II>fileinfo>II<lists.tf<II><I>count_entries>I<<II>info>II<Liefert die Anzahl der Eintraege in der angegebenen Liste. Falls keine Liste uebergeben wurde, wird %error zurueckgegeben.<II>return>II<ueber /result<II>syn>II</count_entries liste|listenname<II>ex>II</let cnt=$(/count_entries demo_list)@{N}/test cnt:=count_entries(demo_list)<II>func>II<isVar<II>changes>II<1.18: Es kann sowohl der Listenname als auch direkt die Liste uebergeben werden. Ausserdem ist es jetzt eine Funktion.<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getdvalueof>I<<II>info>II<Gibt den ersten gefundenen zum Schluessel passenden Wert zurueck und loescht ggf. das Paar.<II>syn>II</getdvalueof listenname schluessel<II>return>II<erster zum Schluessel passender Wert oder %error bei Fehler als Rueckgabewert und in %value<II>see>II</getvalueof, /deletekeyandvalue<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>index>I<<II>info>II<Beim Arbeiten mit Listen und Indizes ist zu beachten, dass die Zaehlung des Index bei Null beginnt!<II>func>II<geti, getidxofkey, getidxofvalue, reggetidxofkey, reggetidxofvalue, delikeyandvalue, getikey, getivalue<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>geti>I<<II>info>II<Liefert den Teil der Liste zurueck, der am Index beginnt. Diese Funktion ist zum internen Gebrauch bestimmt. Der Index beginnt bei Null!<II>syn>II</geti listenname index<II>return>II<Liste ab Index als Rueckgabewert und in %value oder %error, falls index zu gross ist<II>see>II<index, /getikey, /getivalue, /delikeyandvalue<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>delikeyandvalue>I<<II>info>II<Loescht das Paar (Schluessel und Wert) am Index. Der Index beginnt bei Null!<II>syn>II</delikeyandvalue listenname index<II>return>II<%error bei Misserfolg (Index zu gross) als Rueckgabewert und in %value<II>see>II<index, /deletekeyandvalue, /deleteallkeys<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>getivalue liefert den wert an position 'index'. der index beginnt bei null!>I<<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>getivalue>I<<II>syn>II</getivalue listenname index<II>return>II<Wert am Index bzw. %error bei Misserfolg als Rueckgabewert und in %value<II>see>II<index, /getikey, /getidxofvalue<II>mak>II</geti<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getikey>I<<II>info>II<Liefert den Schluessel mit dem angegebenen Index zurueck. Der Index beginnt bei Null!<II>syn>II</getikey listenname index<II>return>II<Schluessel am Index, %error bei Misserfolg als Rueckgabewert und in %value<II>see>II<index, /getivalue, /getidxofkey<II>mak>II</geti<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getkeyofvalue>I<<II>info>II<Liefert zum gegebenen Wert den Schluessel. Wenn der Wert in der Liste nicht eineindeutig ist, wird der erste gefundene Schluessel geliefert.<II>syn>II</getkeyofvalue listenname wert<II>return>II<Schluessel mit diesem Wert, %error bei Misserfolg als Rueckgabewert und in %value<II>see>II</getvalueof<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>iskey>I<<II>info>II<Falls der angegeben Schluessel nicht in der Liste enthalte ist, wird %error zurueckgegeben.<II>syn>II</iskey listenname schluessel<II>return>II<%error bei Misserfolg als Rueckgabewert und in %value<II>see>II</getvalueof<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getdlistvalueof>I<<II>info>II<Holt die Subliste, die dem Schluessel zugeordnet ist, aus der Liste und loescht sie.<II>syn>II</getdlistvalueof listenname schluessel<II>return>II<Subliste, die dem Schluessel zugeordnet ist oder %error bei Misserfolg als Rueckgabewert und in %value<II>see>II</getlistvalueof<II>mak>II</getdvalueof, /makelistofvalue, /unmakesub<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>makesub>I<<II>info>II<Substituiert im String Listentrennzeichen durch Sublistentrennzeichen usw.<II>syn>II</makesub string<II>return>II<per /result<II>see>II</getlistvalueof, /addlisttolist, /unmakesub<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>unmakesub>I<<II>info>II<Substituiert im String Sublistentrennzeichen durch Listentrennzeichen usw.<II>syn>II</unmakesub string<II>return>II<per /result<II>see>II</getlistvalueof, /addlisttolist, /makesub<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>getlistvalueof>I<<II>info>II<Holt die Subliste, die dem Schluessel zugeordnet ist, aus der Liste.<II>syn>II</getlistvalueof listenname schluessel<II>return>II<Subliste, die Schluessel zugeordnet ist, oder %error bei Misserfolg als Rueckgabewert und in %value<II>see>II</getvalueof<II>mak>II</getvalueof, /makelistofvalue, /unmakesub<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>deletekeyandvalue>I<<II>info>II<Loscht das (erste) Paar Schluessel-Wert.<II>syn>II</deletekeyandvalue listenname schluessel<II>return>II<%error bei Misserfolg (Schluessel nicht gefunden) als Rueckgabewert und in %value<II>mak>II</getvalueof<II>see>II</delallkeysandvalues, /delikeyandvalue, /getdvalueof, /getdlistvalueof<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>delallkeysandvalues>I<<II>info>II<Loscht alle Paare Schluessel-Wert.<II>syn>II</delallkeysandvalues listenname schluessel<II>return>II<%error bei Misserfolg (Schluessel nicht gefunden) als Rueckgabewert und in %value<II>mak>II</deletekeyandvalue<II>see>II</deletekeyandvalue, /delikeyandvalue, /getdvalueof, /getdlistvalueof<II>var>II<%value<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>getfirstvalue>I<<II>info>II<Liefert den ersten Wert der Liste zurueck.<II>syn>II</getfirstvalue listenname<II>return>II<erster Wert der Liste oder %error bei Misserfolg Rueckgabewert und in %value<II>mak>II</getfirstkey, /getvalueof<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>getfirstkey>I<<II>info>II<Liefert den ersten Schluessel der Liste zurueck.<II>syn>II</getfirstkey listenname<II>return>II<erster Schluessel der Liste oder %error bei Misserfolg Rueckgabewert und in %value<II>var>II<%value<II>type>II<func<II>fileinfo>II<lists.tf<II><I>hshowlist>I<<II>info>II<Zeigt die angegebene ?Hashliste in einem lesbaren Format an. Sublisten werden eingerueckt.<II>ex>II</hshowlist listenname<II>mak>II</hforEach<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>showlist>I<<II>info>II<Zeigt die angegebene Liste in einem lesbaren Format an. Sublisten werden eingerueckt.<II>syn>II</showlist [-s] [-p] [-e] listenname<II>ex>II</showlist listenname<II>opt>II<-s Sublisten werden rekursiv dargestellt.@{N}-p Die Ausgabe wird mit more seitenweise dargestellt.@{N}-e Die Ausgabe erfolgt auf tferr.<II>mak>II</forEach, /showlist2<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>showlist2>I<<II>info>II<Hilfsmethode von /showlist, fuehrt fuer alle Elemente der Liste die Darstellung durch, ggf. werden Sublisten wieder mit /showlist angezeigt.<II>mak>II</echo2, /unmakesub, /showlist<II>see>II</showlist<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>listkeys>I<<II>info>II<Liefert alle Schluessel der angegebenen Liste als mit Komata getrennte Liste zurueck.<II>return>II<mit /result<II>var>II<%listKeys<II>mak>II</forEach, /listKeys2<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>showshortlist>I<<II>info>II<Zeigt die Liste an, so dass Wert aus Sublisten durch Komata getrennt werden und nicht jeweils auf einer Zeile stehen.<II>ex>II</showshortlist listenname<II>mak>II</foreEach<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>savehrlist>I<<II>info>II<Speichert die angegebene Liste in menschenlesbarer Form. Die Datei heisst 'listenname.hr.list'. Es koennen die von ?/custom verstandenen Optionen verwendet werden.@{N}Achtung, /savehrlist verwendet regmatch(), d.h. %P1 etc. aendern ihre Werte!@{N}Falls beim Speichern ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</savehrlist [/custom-Optionen] listenname<II>mak>II</savehrsublist, /custom<II>var>II<%temp_list, %temp_handle<II>see>II</savelist, tfio, /custom<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>savelist>I<<II>info>II<Speichert die angegebene Liste ab. Die Datei heisst 'listenname.list'. Eine ggf. vorhandene Aenderungsmarkierung wird geloescht. Es koennen die von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Speichern ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</savelist [/custom-Optionen] listenname<II>var>II<%temp_handle, %value<II>mak>II</deletekeyandvalue, /getvalueof, /custom, /addtolist, /deletekeyandvalue, /ifecho<II>see>II</savehrlist, tfio, /custom<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>loadnamedlist>I<<II>info>II<Laedt die Liste, die den Namen %parameter_list_name hat und in den Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die der Parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</loadnamedlist paket_prefix<II>ex>II<Nach@{N}@{}  /set waffen_list_name=waffen@{N}@{}  /set waffen_list_location=ausruestung@{N}wuerde@{N}@{}  /loadnamedlist waffen@{N}die Liste waffen laden, welche im File ausruestung/waffen.list gespeichert ist.<II>see>II</savenamedlist, /loadlist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>savenamedlist>I<<II>info>II<Speichert die Liste, die den Namen %parameter_list_name hat in dem Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die der Parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</savenamedlist paket_prefix<II>ex>II<Nach@{N}@{}  /set waffen_list_name=waffen@{N}@{}  /set waffen_list_location=ausruestung@{N}wuerde@{N}@{}  /savenamedlist waffen@{N}die Liste waffen im File ausruestung/waffen.list speichern.<II>see>II</loadnamedlist, /savelist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>hloadnamedlist>I<<II>info>II<Laedt die Liste, die den Namen %parameter_list_name hat und in den Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</hloadnamedlist paket_prefix<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>hsavenamedlist>I<<II>info>II<Speichert die Liste, die den Namen %parameter_list_name hat in dem Verzeichnis das durch die Optionen in %parameter_list_location vorgegeben ist. Dies ist vor allem fuer Pakete notwendig, fuer die parameter sinnvollerweise der Name des Pakets ist.<II>syn>II</hsavenamedlist paket_prefix<II>type>II<mak<II>fileinfo>II<lists.tf<II><I>loadlist>I<<II>info>II<Laedt die angegebene Liste aus der Datei 'listenname.list'. Dabei wird ihre Laenge als Veraenderungserkennung gemerkt. Es koennen die von ?/custom verstandenen Optionen verwendet werden. Falls /loadlist das File nicht laden kann, werden schon existente Listen unberuehrt gelassen, ansonsten wird eine neue Liste intialisiert.@{N}Gibt %error bei Fehler zurueck.<II>syn>II</loadlist [/custom-Optionen] listenname<II>mak>II</addlisttosave, /createlist, /custom, /ifecho<II>see>II</savelist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>addlisttosave>I<<II>info>II<Speichert die Laenge der angegebenen Liste als Veraenderungsmerkmal.<II>syn>II</addlisttosave listenname<II>mak>II</deletekeyandvalue, /addtolist<II>see>II</savelist, /loadlist<II>list>II<lists<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>savealllists>I<<II>info>II<Speichert die veraenderten Listen ab.<II>syn>II</savealllists<II>mak>II</createlist, /foreach<II>see>II</savelist, /loadlist<II>list>II<lists<II>var>II<%tlists, %hlists2<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>lists>I<<II>info>II<Ist eine Liste, die die geladenen Listen und deren Laenge beim Laden enthaelt. Die Laenge wird dann mit der aktuellen Laenge verglichen, um etwaige Veraenderungen feststellen zu koennen.<II>see>II</savealllists, /addlisttosave, /loadlist<II>type>II<list<II>fileinfo>II<lists.tf<II><I>loadhrlist>I<<II>info>II<Laedt die angegebene Liste aus der Datei 'listenname.hr.list'. Dabei wird ihre Laenge als Veraenderungserkennung gemerkt. Es koennen alle von ?/custom verstandenen Optionen verwendet werden.@{N}Falls beim Laden ein Fehler auftrat, wird %error zurueckgegeben.<II>syn>II</loadhrlist [/custom-Optionen] listenname<II>mak>II</addlisttosave, /createlist, /custom, /ifecho<II>see>II</savehrlist, /loadlist, /savelist<II>type>II<comm<II>fileinfo>II<lists.tf<II><I>isemptylist>I<<II>info>II<Funktion, die 1 zurueckgibt, falls die uebergenen Liste leer ist, sonst 0.@{N}Achtung: Falls der uebergebene Parameter keine Liste ist, wird ebenfalls 0 zurueckgegeben.<II>see>II<isList<II>syn>II</isEmptyList listenname<II>ex>II</if (isEmptyList(test_list)) /echo Liste leer%; /endif@{N}/test isempy:=isEmptyList(test_list)<II>type>II<func<II>fileinfo>II<lists.tf<II><I>listen>I<<II>info>II<Die Listenverwaltung bildet den Grundstock fuer alle anderen Makros.@{N}Die Listen bestehen jeweils aus Schluessel-Wert-Paaren, die durch Trennzeichen getrennt in einem grossen String stehen. Der Wert eines Schluessels kann auch wieder eine (Sub)Liste sein.@{N}Achtung: Die Liste 'list' wird fuer interne Zwecke benoetigt und sollte nicht verwendet werden.<II>see>II</createlist, /addtolist, /getvalueof usw.<II>type>II<misc<II>fileinfo>II<lists.tf<II><I>lists.tf>I<<II>info>II<Enthaelt Makros zum Umgang mit Listen, die aus Schluessel-Wert-Paaren bestehen; dabei kann der Wert auch wieder eine Liste sein.<II>var>II<%value (ganz wichtig)<II>see>II<index, listen<II>req>II<loading.tf, util.tf<II>changes>II<1.20 Viele Makros geben nun ihr Ergebnis nicht nur in %value, sondern auch als Rueckgabewert zurueck. Die Verwendung von %value sollte soweit wie moeglich vermieden werden, um Seiteneffekte zu vermeiden.<II>misc>II<hashliste, result anzahl der eintraege als rueckgabewert, felder, result das sortierte feld in %amsort_base und das ggf. mitzusortierende zweite feld in %amsort_base2., index, getivalue liefert den wert an position 'index'. der index beginnt bei null!, listen<II>comm>II<hashlist, removehashed, hxaddtolist, haddtolist, haddlisttosave, hcreatelist, hcopylist, hloadlist, hsavelist, hgetvalueof, hdelallkeysandvalues, hdeletekeyandvalue, hgetdvalueof, hgetlistvalueof, hxaddlisttolist, aput, aclear, ashow, asshow, amsort, asort, aforeach, aforeach2, asortforeach, hasortforeach, createlist, createnewlist, xaddbtolist, xaddtolist, xuaddtolist, addtolist, uaddtolist, addbtolist, addlisttolist, uaddlisttolist, xaddlisttolist, foreach, delikeyandvalue, getdlistvalueof, getlistvalueof, deletekeyandvalue, delallkeysandvalues, hshowlist, showlist, listkeys, showshortlist, savehrlist, savelist, loadnamedlist, savenamedlist, loadlist, addlisttosave, savealllists, loadhrlist<II>mak>II<sreplace, sortforeach, hsortforeach, hforeach, haddlisttolist, hgetentrylist, aswap, amsort1, split_list, merge_lists, umerge_lists2, hmerge_lists, makesub, unmakesub, showlist2, hloadnamedlist, hsavenamedlist<II>func>II<paramparse, islist, hcount_entries, aget, alen, astart, ascmp, asicmp, ancmp, reggetvalueof, convert_regexp, reggetkey, reggetkeyofvalue, reggetvalue, getidxofvalue, getidxofkey, reggetidxofvalue, reggetidxofkey, getvalueof, getnextvalueof, count_entries, getdvalueof, geti, getivalue, getikey, getkeyofvalue, iskey, getfirstvalue, getfirstkey, isemptylist<II>list>II<lists<II>version>II<lists.tf,v 1.27 2002/03/14 14:28:09 nieten (Mesirii@mg.mud.de)<II>req>II<util.tf loading.tf<II>type>II<fileinfo<II>fileinfo>II<lists.tf<II><I>map_locale>I<<II>info>II<mappt die verschiedenen Auspraegungen einer locale (z.B. deutsch, german, de_DE, de_AU usw) auf eine locale. Dazu wird entweder bei de_DE nur der erste Teil genommen, bei german usw. sollte eine Variable locale_german mit de gesetzt sein.<II>return>II<per result, Ziellocale oder Parameter<II>ex>II</test map_locale("german"), /map_locale %%LANG<II>syn>II</map_locale localebez<II>see>II<add_loc, loc<II>type>II<mak<II>fileinfo>II<i18n.tf<II><I>add_loc>I<<II>info>II<Fgt neue Lokalisierungsstrings hinzu<II>list>II<i18n, add_loc (temporaer)<II>see>II<loc<II>syn>II</test add_loc("base_string","base_locale","string","locale","string2","locale2")<II>ex>II</test add_loc("Deutscher Text","de","German Text","en")<II>type>II<mak<II>fileinfo>II<i18n.tf<II><I>loc>I<<II>info>II<Lokalisiert einen bergebenen String, dazu wird in der Liste i18n, der String gesucht und dann die Uebersetzung fuer die aktuelle Locale (in LANG) zurueckgegeben, falls die aktuelle Locale mit der Basislocale uebereinstimmt, wird nicht gesucht.<II>syn>II</test loc("String","locale des Strings")<II>ex>II</test loc("Das ist ein Text","de") : bei LANG=en "This is a text"<II>return>II<per /result<II>list>II<i18n<II>see>II<add_loc, LANG<II>type>II<mak<II>fileinfo>II<i18n.tf<II><I>i18n.tf>I<<II>mak>II<map_locale, add_loc, loc<II>version>II<i18n.tf,v 1.6 2001/11/27 13:50:41 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf<II>info>II<Internationalisierung<II>type>II<fileinfo<II>fileinfo>II<i18n.tf<II><I>abbreviations>I<<II>info>II<Diese Liste enthaelt die definierten Abkuerzungen und deren Liste von Inhalten.<II>type>II<list<II>fileinfo>II<util.abbrev.tf<II><I>def_abbrev>I<<II>info>II<Definiert eine Abkuerzung, indem sie sie in die Liste ?abbreviations eintraegt. Danach wird jeder Text, der ^abkuerzung enthaelt und ans Mud geschickt werden soll, vervielfaeltigt und jeweils ein Eintrag der Abkuerzung eingetragen.<II>ex>II</def_abbrev freunde mesirii strohalm@{N}Damit wird aus 'teile ^freunde mit test'@{N}-> 'teile mesirii mit test' und@{N}-> 'teile strohalm mit test'@{N}Pausen koennen mit '/def_abbrev zauber *3 schutz hand' eingestellt werden (3 Sekunden) oder mit 'zaubere ^3zauber' beim Ausfuehren angegeben werden. Dabei sind die Pausen beim Ausfuehren vorrangig. Dank Strohalm sind jetzt durch _ statt Leerzeichen getrennte Worte in den Abkuerzungen moeglich; diese werden bei der Umsetzung wieder durch Leerzeichen ersetzt.<II>type>II<comm<II>fileinfo>II<util.abbrev.tf<II><I>undef_abbrev>I<<II>info>II<Loescht eine Abkuerzung<II>ex>II</undef_abbrev freunde<II>type>II<comm<II>fileinfo>II<util.abbrev.tf<II><I>h_abbrev>I<<II>info>II<Dieser Send-Hook faengt die Abkuerzungen ab und ersetzt sie wie bei /def_abbrev beschrieben.<II>list>II<abbreviations<II>mak>II<tokenize<II>type>II<hook<II>fileinfo>II<util.abbrev.tf<II><I>util.abbrev.tf>I<<II>comm>II<def_abbrev, undef_abbrev<II>hook>II<h_abbrev<II>list>II<abbreviations<II>version>II<util.abbrev.tf,v 1.8 2001/11/27 21:34:06 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf util.sfuncs.tf<II>info>II<Abkuerzungen, die in multiple Mud-Kommandos expandiert werden<II>type>II<fileinfo<II>fileinfo>II<util.abbrev.tf<II><I>completion_recall_count>I<<II>info>II<Anzahl der Zeilen im Recall, die die ?completion zurueckgehen soll (Default 200).<II>see>II<completion<II>type>II<var<II>fileinfo>II<util.completion.tf<II><I>completion>I<<II>info>II<Vervollstaendigt den bisher eingegebenen Text automatisch. Dabei werden die Vorschlaege kontextsensitiv ermittelt. Wenn ein % vorher steht, werden Variablen, bei / werden Makronamen, bei ? einer der Knoten des Wegesystems, bei @ einer der anwesenden Spieler, bei & ein Item aus dem Invetory und ansonsten Text aus dem Mud (?completion_recall_count (default 200 Zeilen zurueck) verwendet. Durch mehrmaliges Druecken der Taste werden alle Moeglichkeiten durchgespielt.<II>var>II<completion_list, completion_line, last_completion, completion_recall_count, mud_set_line_count, mud_invetory, mud_short_who<II>adapt>II<completion_recall_count, mud_set_line_count, mud_inventory, mud_short_who<II>type>II<comm<II>fileinfo>II<util.completion.tf<II><I>util.completion.tf>I<<II>comm>II<completion<II>var>II<completion_recall_count<II>version>II<util.completion.tf,v 1.6 2001/11/27 21:33:49 mh14 (Mesirii@mg.mud.de)<II>req>II<util.trigger.tf<II>info>II<Erweiterte Vervollstaendigung (Completion)<II>type>II<fileinfo<II>fileinfo>II<util.completion.tf<II><I>debug>I<<II>info>II<Macht nur ein /echo der Parameter, wenn die Variable 'debug' auf 1 gesetzt ist.<II>var>II<debug<II>type>II<mak<II>fileinfo>II<util.debug.tf<II><I>vdebug>I<<II>info>II<Gibt alle Variablen, die /vdebug als Parameter uebergeben werden, mit Name und Wert auf stderr aus, wenn 'debug' auf 1 gesetzt ist.<II>type>II<mak<II>fileinfo>II<util.debug.tf<II><I>test_result>I<<II>info>II<Wertet das Ergebnis eines Unit Test Bestandteils aus. Dazu wird als Parameter die Testbedingung uebergeben. Die Variablen param und res muessen im Test benutzt werden, und sind hier als lokale Variablen verfuegbar<II>ex>II</test_result<II>syn>II</test_result Bedingung<II>var>II<res, param<II>type>II<mak<II>fileinfo>II<util.debug.tf<II><I>watch_list>I<<II>info>II<Diese Liste enthaelt die Namen der zu ueberwachenden Variablen als Key und ihre Inhalte als Value. Sie wird mittels /watch_loop und /watch_check_var aktualisiert.<II>see>II</watch_var, /watch_loop, /watch_check_var, watch_action_list<II>type>II<list<II>fileinfo>II<util.debug.tf<II><I>watch_action_list>I<<II>info>II<Falls bei Aenderung einer Variablen ein Makro aufgerufen werden soll, steht das Paar Variablenname/Makro in dieser Liste.<II>see>II</watch_var, /watch_loop, /watch_check_var, watch_list<II>type>II<list<II>fileinfo>II<util.debug.tf<II><I>watch_time>I<<II>info>II<Legt das Zeitintervall (in Sekunden) fest, in dem die zu ueberwachenden Variablen auf etwaige Veraenderungen geprueft werden.@{N}Sollte insbesondere auf langsamen Rechnern nicht zu klein gewaehlt werden. Der Wert 0 beendet die Ueberwachung.<II>see>II</watch_loop<II>type>II<var<II>fileinfo>II<util.debug.tf<II><I>watch_active>I<<II>info>II<Dieses Flag regelt, ob eine Variablenueberwachung stattfindet.<II>see>II</watch_loop, /watch_var<II>type>II<var<II>fileinfo>II<util.debug.tf<II><I>watch_var>I<<II>info>II<Mit diesem Makro lassen sich Aenderungen von Variableninhalten ueberwachen. Dazu wird in der Liste ?watch_list fuer jede zu ueberwachende Variable ihr Name und aktueller Inhalt gespeichert. Diese Liste wird dann mittels ?/watch_loop bzw. ?/watch_check_var alle ?%watch_time Sekunden mit den aktuellen Werten verglichen. Wurde eine Veraenderung festgestellt, wird diese ausgegeben und die Liste aktualiesert.@{N}Aufrufmoeglichkeiten:@{N}1. ohne Parameter: Startet bzw. stoppt die Variablenueberwachung.@{N}2. ein Parameter: Falls der Parameter der Name einer globalen Variable ist, wird sie mit ihrem aktuellen Inhalt an die Liste watch_list angehaengt bzw. aus ihr geloescht, falls sie dort schon vorhanden war. Auerdem wird die Variablenueberwachung gestartet, falls dies noch nicht der Fall war.@{N}3. mehr als ein Parameter: Wie bei 2., jedoch wird der restliche Teil der Parameter in der Liste ?watch_action_list eingetragen und ausgefuehrt, falls sich die angegebene Variable aendert.@{N}(Durch "/set watch_active=0" wird uebrigens nach spaetestens %watch_time Sekunden die Ueberwachung komplett beendet.)<II>ex>II</watch_var LP@{N}startet die Ueberwachung der globalen Variable %LP. Nach@{N}/set LP=-200@{N}erscheint nach kurzer Zeit@{N}# watch: %LP=-200@{N}Moechte man die Ueberwachung von %LP beenden, genuegt ein zweiter Aufruf von@{N}/watch_var LP@{N}Moechte man die Veraendung von %LP hervorheben, so laesst sich das z. B. mit@{N}/watch_var LP /echo -aCyellow aktuelle LP: %LP@{N}erreichen. Eine Veraendung von %LP fuehrt dann zu@{N}# watch: %LP=-200@{N}@{Cyellow}aktuelle LP: -200@{n}<II>see>II</watch_loop, %watch_time, %watch_active, watch_list, watch_action_list<II>var>II<%watch_active<II>list>II<watch_list, watch_action_list<II>syn>II</watch_var [Variablenname [Makro]]<II>type>II<comm<II>fileinfo>II<util.debug.tf<II><I>watch_loop>I<<II>info>II<Falls ?%watch_active und %watch_time beide nicht 0 sind, ruft fuer jede in ?watch_list aufgefuehrte Variable ?/watch_check_var auf. Danach wird %watch_list aktualisiert. Anschliessend ruft /watch_loop sich mit einer Verzoegerung von %watch_time Sekunden selber wieder auf.<II>list>II<watch_list<II>var>II<%watch_active, %watch_time<II>mak>II</watch_check_var<II>type>II<mak<II>fileinfo>II<util.debug.tf<II><I>watch_check_var>I<<II>info>II<Ueberprueft, ob die als erster Parameter uebergebene Variable als Wert die uebrigen Parameter enthaelt. Ist dies nicht der Fall, wird eine entsprechende Meldung ausgegeben. Taucht die Variable in ?watch_action_list auf, so wird dann ausserdem das ihr zugewiesen Makro ausgefuehrt. In jedem Fall wird das Paar Variablename/aktueller Wert an die Liste watch_tmp_list angehaengt.<II>syn>II</watch_check_var Variablenname Wert<II>list>II<watch_list, watch_action_list<II>type>II<mak<II>fileinfo>II<util.debug.tf<II><I>util.debug.tf>I<<II>comm>II<watch_var<II>mak>II<debug, vdebug, test_result, watch_loop, watch_check_var<II>var>II<watch_time, watch_active<II>list>II<watch_list, watch_action_list<II>version>II<util.debug.tf,v 1.8 2002/03/27 01:33:19 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf<II>info>II<Debug-Funktionen, Variablenueberwachung<II>type>II<fileinfo<II>fileinfo>II<util.debug.tf<II><I>echo2>I<<II>info>II<Erweitert die Funktionalitaet des '-p'-Parameters von /echo um das Attribut '@@@{}{N}', welches einen Zeilenumbruch hervorruft.<II>see>II<echo, attributes<II>type>II<comm<II>fileinfo>II<util.echo.tf<II><I>echolist>I<<II>info>II<Sammelt eine Anzahl von Ausgaben und gibt sie beim Aufruf ohne Parameter durch Kommata getrennt wieder aus.<II>var>II<%echolist<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>init_col_echo>I<<II>info>II<Initialisiert die Ausgabebreite und die Spaltenbreite fuer die naechsten /col_echo.<II>ex>II</init_col_echo 80 15<II>syn>II</init_col_echo width col_width<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>col_echo>I<<II>info>II<Gibt solange Text in laut /init_col_echo gestalteten Zeilen aus, bis es ohne Parameter aufgerufen wird. Der Text wird spaltenweise formatiert.Wwenn Text zu lang ist, ragt er bis auf die naechsten Spalten ueber.<II>syn>II</col_echo Text oder kein Parameter zum Beenden<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>ifecho>I<<II>info>II<Macht nur die Ausgabe, wenn der als erste Parameter uebergebene Ausdruck wahr ist.<II>ex>II</ifecho debuglevel=10 Internal Warning<II>syn>II</ifecho expression Text<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>ext_read>I<<II>info>II<Ein erweitertes Read, dass einen Praefix als Prompt setzt und einen Standardwert in die Eingabezeile schreibt.<II>syn>II</ext_read praefix [defaultwert]<II>ex>II</ext_read Auswahl 10<II>see>II<prompt<II>type>II<func<II>fileinfo>II<util.echo.tf<II><I>simple_menu>I<<II>info>II<Ein einfaches Menue, dass seine Parameter nummeriert darstellt und als Ergebnis eine darauf normierte Zahl zurueckgibt (oder 0 im Fehlerfall)<II>ex>II</simple_menu Laden Speichern Schliessen<II>return>II<Auswahl oder 0 bei Fehler<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>line>I<<II>info>II<Zeichnet eine Linie ueber den gesamten Bildschirm, wenn ein Parameter angegeben wurde, wird dieser in der Zeile zentriert<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>format_success_text>I<<II>info>II<formats the given Text according to the Variables format_attr_*<II>cfg>II<format_attr_*<II>ex>II</format_success_text success Done -> formatted text done (for /echo -p) according to the format_attr_success<II>type>II<mak<II>fileinfo>II<util.echo.tf<II><I>remove_attributes>I<<II>info>II<Loescht im uebergebenen String alle Attributsdefinitionen. Nuetzlich fuer Ausgabe in Logfiles oder in den Prompt.<II>ex>II<Die Zeile@{N}/echo -p @@{Ccyan}$[remove_attributes("nicht @@{Cred}rot")]@{N}erzeugt als Ausgabe@{N}@{Ccyan}nicht rot@{n}<II>return>II<String ohne Attributsanweisungen<II>type>II<func<II>fileinfo>II<util.echo.tf<II><I>util.echo.tf>I<<II>comm>II<echo2<II>mak>II<echolist, init_col_echo, col_echo, ifecho, simple_menu, line, format_success_text<II>func>II<ext_read, remove_attributes<II>version>II<util.echo.tf,v 1.13 2002/03/07 15:49:55 nieten (Mesirii@mg.mud.de)<II>req>II<util.vfunc.tf<II>info>II<Echo Erweiterungen (Spalten, bedingt, Zeilenumbruch)<II>type>II<fileinfo<II>fileinfo>II<util.echo.tf<II><I>hooks>I<<II>info>II<Die Hooks sind eine Ansammlung von Befehlen, die in den Makros hook_hookname gespeichert sind. Ueber die Ausfuehrungsreihenfolge kann keine Annahme getroffen werden. Sie sind dazu praktisch, bei einem Ereignis eine Reihe vorher nicht festgelegter Anweisungen auszufuehren.<II>see>II</eval_hook, /add_to_hook, /remove_from_hook, /remove_hook<II>type>II<see<II>fileinfo>II<util.hooks.tf<II><I>add_to_hook>I<<II>info>II<Fuegt zu dem angegebenen Hook Anweisungen hinzu. Dabei sollte die letzte nicht mit '%;' abgeschlossen werden. Im Hook kann auf die Makroparameter Bezug genommen werden.<II>syn>II</add_to_hook hookname anweisungen<II>ex>II</add_to_hook reload /mload %param<II>mak>II<hook_%hookname<II>version>II<1.01<II>changes>II<1.01 testet, ob hook existiert<II>type>II<mak<II>fileinfo>II<util.hooks.tf<II><I>add_to_hook_begin>I<<II>info>II<Fuegt dem angegebenen Hook Anweisungen als erste Anweisungen an. Dabei sollte die letzte nicht mit '%;' abgeschlossen werden. Im Hook kann auf die Makroparameter Bezug genommen werden.<II>syn>II</add_to_hook_begin hookname anweisungen<II>ex>II</add_to_hook_begin reload /mload %param<II>mak>II<hook_%hookname<II>version>II<1.01<II>changes>II<1.01 testet, ob hook existiert<II>type>II<mak<II>fileinfo>II<util.hooks.tf<II><I>remove_from_hook>I<<II>info>II<Entfernt aus dem angegebenen Hook vorher hinzugefuegte Anweisungen. Dazu muss der String exakt uebereinstimmen.<II>syn>II</remove_from_hook hookname anweisungen<II>ex>II</add_to_hook testhook /echo %*@{N}/remove_from_hook /echo %*<II>type>II<mak<II>fileinfo>II<util.hooks.tf<II><I>remove_hook>I<<II>version>II<1.01<II>info>II<Entfernt den angegebenen Hook.<II>syn>II</remove_hook hookname<II>type>II<mak<II>fileinfo>II<util.hooks.tf<II><I>eval_hook>I<<II>info>II<Fuehrt den angegebenen Hook mit den uebergebenen Parametern aus.<II>mak>II<hook_%hookname<II>version>II<1.01<II>changes>II<1.01 Testet, ob Hook existiert.<II>type>II<mak<II>fileinfo>II<util.hooks.tf<II><I>util.hooks.tf>I<<II>see>II<hooks<II>mak>II<add_to_hook, add_to_hook_begin, remove_from_hook, remove_hook, eval_hook<II>version>II<util.hooks.tf,v 1.8 2001/10/19 14:36:11 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Hooks=einfach erweiterbare Makrolisten, die bei bestimmten Gelegenheiten aufgerufen werden koennen<II>type>II<fileinfo<II>fileinfo>II<util.hooks.tf<II><I>init_action_count>I<<II>info>II<Initialisiert das Zaehlen von Befehlen und Prompts in den Variablen '_${world_name}(action|prompt)_count'. Dazu wird die Liste 'prompt_action' erzeugt und /def_prompt_hook aufgerufen.<II>see>II<def_prompt_hook<II>type>II<mak<II>fileinfo>II<util.prompts.tf<II><I>add_action_count>I<<II>info>II<Erhoeht den Zaehler fuer die ans Mud geschickten Befehle. Ist vor allem fuer SEND-Hooks notwendig, die die Daten per /send ans Mud schicken, und ueberall sonst, wo /send benutzt wird.<II>syn>II</add_catchup_action Zahl der Kommandos<II>type>II<mak<II>fileinfo>II<util.prompts.tf<II><I>clear_actions>I<<II>info>II<Da es immer wieder mal passiert, dass die Zaehlung durcheinanderkommt, werden hiermit die Liste 'prompt_action' geloescht und die Variablen auf denselben Wert (action_count) gesetzt.<II>type>II<mak<II>fileinfo>II<util.prompts.tf<II><I>lists promt_action>I<<II>info>II<Fuehrt nach dem erfolgreichen Ausfuehren der x naechsten Befehle, die ans Mud geschickt werden, den angegebenen Code aus. Dieser wird in einer Liste gespeichert und vom Hook 'h_action_prompt' ausgefuehrt. Es wird auf die Zahl der bisher gesendeten Befehle der Parameter (Standard 1) aufaddiert, und nach dieser Zahl Prompts wird der Code ausgefuehrt.<II>ex>II<n%;n%;o%;@{N}/promt_action 5 /echo fertig%;@{N}o%;n%;ob%;s%;w%; (wenn diese Befehle vom Mud fertig ausgefuehrt wurden, kommt das '/echo fertig')<II>syn>II</add_prompt_action (Zahl der abzuwartetende Befehle) Code<II>see>II<def_prompt_hook<II>type>II<misc<II>fileinfo>II<util.prompts.tf<II><I>add_prompt_action>I<<II>type>II<mak<II>fileinfo>II<util.prompts.tf<II><I>h_action>I<<II>info>II<<II>info>II<Hook der den letzten Zeitpunkt speichert, an dem etwas ans Mud geschickt wurde. Wird von /check_idle genutzt.<II>type>II<hook<II>fileinfo>II<util.prompts.tf<II><I>util.prompts.tf>I<<II>misc>II<lists promt_action<II>mak>II<init_action_count, add_action_count, clear_actions, add_prompt_action<II>hook>II<h_action<II>version>II<util.prompts.tf,v 1.10 2001/10/10 22:10:21 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf util.hooks.tf<II>info>II<Makros zum Nutzen der Prompts, des Muds um Makros auszufuehren<II>type>II<fileinfo<II>fileinfo>II<util.prompts.tf<II><I>my_quote>I<<II>info>II<Erlaubt es mehrzeilgen Text mit Zeilenumbruechen ins tf zu pasten, so dass jede Zeile mit dem Prefix ans Mud gesendet wird<II>ex>II</my_quote sage <Enter druecken>, dann Text pasten und mit Escape-q beenden<II>type>II<comm<II>fileinfo>II<util.quote.tf<II><I>spare_linefeeds>I<<II>info>II<Erlaubt es, mehrzeiligen Text mit Zeilenumbruechen ins tf zu pasten, ohne dass die Zeilenumbrueche als Returns gewertet werden, und diesen Text insgesamt mit einem Prefix versehen ans Mud zu schicken bzw. ihn im TF zu verwenden. Die Zeilenumbrueche werden mit einem SPACE ersetzt.<II>ex>II</spare_linefeeds sage <Enter druecken>, dann Text pasten und mit Escape-q beenden@{N}oder /spare_linefeeds <Enter druecken> und dann eine /def pasten und mit Escape-q beenden<II>type>II<comm<II>fileinfo>II<util.quote.tf<II><I>mud_quote>I<<II>info>II<Schickt die Ausgabe des angegeben Mud-Kommandos mit dem angegebenen Prefix wieder ans Mud.<II>ex>II</mud_quote sage 'inventar@{N}Der erste Parameter ist das Prefixkommando, und das nach dem ' das Kommando, dessen Ausgabe genutzt werden soll.<II>type>II<comm<II>fileinfo>II<util.quote.tf<II><I>util.quote.tf>I<<II>comm>II<my_quote, spare_linefeeds, mud_quote<II>version>II<util.quote.tf,v 1.5 2001/09/09 19:09:42 mh14 (Mesirii@mg.mud.de)<II>req>II<util.trigger.tf util.echo.tf<II>info>II<Pasten in tf Fenster, Quoten von Mud-Ausgaben ans Mud<II>type>II<fileinfo<II>fileinfo>II<util.quote.tf<II><I>countdown>I<<II>info>II<Zaehlt die uebergebene Variable im Sekundentakt bis auf 0 herunter. Alternativ kann statt des Sekundentakts auch ein anderer Zeitschritt angegeben werden. Nuetzlich z.B. fuer Zeitsperren, die in der Statuszeile angezeigt werden sollen. Wenn nach dem Herunterzaehlen ein Makro ausgefuehrt werden soll, muss es nach dem dann notwendigen Takt angegeben werden.<II>syn>II</countdown varname [takt]@{N}/countdown varname takt makro<II>type>II<mak<II>fileinfo>II<util.repeat.tf<II><I>n>I<<II>info>II<Wiederholt den als Restparameter uebergebenen String Parameter1-mal. Dabei ist es egal, ob es sich um Mud- oder tf-Kommandos handelt. Der Zaehler von /n (Variable n) kann auch im Code genutzt werden.<II>ex>II</n 5 nimm alles aus leiche %n (oder besser /n 5 nl %n)<II>type>II<comm<II>fileinfo>II<util.repeat.tf<II><I>n2>I<<II>info>II<Wiederholt den als Restparameter uebergebenen String sooft, wie er den Parameter 1 halbieren kann. Dabei ist es egal, ob es sich um Mud- oder tf-Kommandos handelt. Der Zaehler von /n2  (Variable n2) kann auch im Code genutz werden.<II>ex>II<z.B. soviele Muenzen wie moeglich tragen ;) @{N}/n2 100000 nimm %n2 muenzen (oder besser /n 100000 nm %n2)<II>type>II<comm<II>fileinfo>II<util.repeat.tf<II><I>beat>I<<II>info>II<Fuer wiederkehrende Aufgaben aehnlich eines cron-Jobs wird festgelegt, alle wieviel (n) Sekunden sie ausgefuehrt werden (Parameter), dann kann der Hook 'beat_n' mit den entsprechenden Makros gefuellt werden, die zu diesem Zeitpunkt ausgefuehrt werden sollen.@{N}Gesteuert wird das ganze durch die Variablen 'do_beat', die alle Beats anhalten kann (0) oder wieder laufen lassen (1), und durch 'do_beat_n', die das ebenso fuer die einzelnen Beats steuert.@{N}In der Variablen 'beat_pid_n' steht die pid des letzten repeats des beat.<II>var>II<do_beat, do_beat_n, beat_pid_n<II>see>II<hooks,repeat<II>ex>II<Aller 10 Sekunden ein Beep /beat 10 1%;/add_to_hook beat_10 /echo Beep<II>syn>II</beat repeat_sek run_now(1|0)<II>type>II<mak<II>fileinfo>II<util.repeat.tf<II><I>util.repeat.tf>I<<II>comm>II<n, n2<II>mak>II<countdown, beat<II>version>II<util.repeat.tf,v 1.7 2001/09/09 22:21:39 mh14 (Mesirii@mg.mud.de)<II>req>II<util.hooks.tf<II>info>II<Countdown,Heartbeats,Kommando-Counter<II>type>II<fileinfo<II>fileinfo>II<util.repeat.tf<II><I>tokenize>I<<II>info>II<Spaltet Strings entsprechend der angegebenen Begrenzer auf.<II>syn>II<$[tokenize("begrenzer z.b. space Komma usw.","string")]<II>return>II<%T0 anzahl der aufspaltungen@{N}%Ti ite aufspaltung<II>version>II<1.01<II>type>II<mak<II>fileinfo>II<util.sfunc.tf<II><I>sprintf>I<<II>info>II<Ersetzt die nummerierten #i im uebergebenen String durch die i-ten Parameter, die sprintf uebergeben wurden.<II>ex>II</test sprintf("#1 Bytes von #2 gelesen",100,"test.txt")<II>syn>II</test sprintf("String",parameters,...)<II>return>II<String mit Ersetzungen<II>type>II<func<II>fileinfo>II<util.sfunc.tf<II><I>strnstr>I<<II>info>II<Sucht den String2 ab der angegebenen Position im String1.<II>syn>II<strnstr(string1,off,string2)<II>return>II<den Offset von String2 vom Beginn von String1 oder -1 bei Fehler<II>type>II<mak<II>fileinfo>II<util.sfunc.tf<II><I>capitalize>I<<II>info>II<Liefert den uebergebenen Text mit Grossbuchstaben am Anfang zurueck.<II>type>II<mak<II>fileinfo>II<util.sfunc.tf<II><I>hash1>I<<II>info>II<Liefert einen Hashwert des uebergebenen Strings zurueck. Dieser wird gebildet, indem eine Verkettung aus Stringlaenge modulo 1000, sowie den ASCII Werten der folgenden Zeichen erzeugt wird. 1. Zeichen bei Position Stringlaenge modulo 100 (als Prozentwert dividiert durch 100) mal Stringlaenge (hier mod. 1000, ist aber nicht so wichtig). 2. Zeichen bei Stringlaenge (mod 1000) - Position1.@{N}Wenn der String weniger als 10 Zeichen beinhaltet, wird der Hashcode nach folgender Formel berechnet: x=0, x:=x*8+ascii(i), i=0..strlen<II>syn>II</hash1 string, Returnwert per /result<II>type>II<mak<II>fileinfo>II<util.sfunc.tf<II><I>util.sfunc.tf>I<<II>mak>II<tokenize, strnstr, capitalize, hash1<II>func>II<sprintf<II>version>II<util.sfunc.tf,v 1.6 2001/11/28 11:02:55 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Stringfunktionen, Aufspalten, Hashcode, Sprintf<II>type>II<fileinfo<II>fileinfo>II<util.sfunc.tf<II><I>stack_push>I<<II>info>II<Speichert die uebergebenen (globalen) Variablen auf dem Stack.<II>ex>II</stack_push t1 t2 t3<II>see>II<getstack, stack_put, stack_pop<II>type>II<mak<II>fileinfo>II<util.stack.tf<II><I>stack_put>I<<II>info>II<Speichert die uebergebene (globale) Variable auf dem Stack in der angegebenen Position. Die Position muss innerhalb des Stackpointers liegen.<II>ex>II</stack_put 1 test oder /stack_put test 1<II>see>II<getstack, stack_push, stack_pop<II>type>II<mak<II>fileinfo>II<util.stack.tf<II><I>getstack>I<<II>info>II<Holt von der angegebenen Position eine Variable aus dem Stack. Wenn ein Variablenname uebergeben wird, wird der Wert in dieser Variablen gespeichert. Die Position muss innerhalb des Stackpointers liegen.<II>ex>II</getstack 1 test oder /getstack test 3 oder /getstack 2<II>return>II<der Inhalt der Variablen<II>see>II<stack_put, stack_push, stack_pop<II>type>II<mak<II>fileinfo>II<util.stack.tf<II><I>stack_pop>I<<II>info>II<Holt eine/viele Variable aus dem Stack. Wenn Variablenname(n) uebergeben werden, wird der Wert in dieser Variablen gespeichert.<II>ex>II</stack_pop @{N} /stack_pop test @{N} /stack_pop test test2<II>return>II<der Inhalt der letzten Variablen<II>see>II<stack_push, getstack, stack_put<II>type>II<mak<II>fileinfo>II<util.stack.tf<II><I>util.stack.tf>I<<II>mak>II<stack_push, stack_put, getstack, stack_pop<II>version>II<util.stack.tf,v 1.6 2001/11/30 13:44:12 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Diverse Stackfunktionen<II>type>II<fileinfo<II>fileinfo>II<util.stack.tf<II><I>timer_makro>I<<II>info>II<Enthaelt den Makrobody, der vom ?timer beim Ausfuehren des Triggers aufgerufen wird. In %1 steht die vergangene Zeit.<II>see>II<timer<II>type>II<var<II>fileinfo>II<util.timer.tf<II><I>timer>I<<II>info>II<Ein Timer, der im Sekundenbereich misst, also eher fuer Mud-Probleme gedacht ist. Beim Anlegen des Timers kann ein Trigger definiert werden, der dann den Makro-Body in ?timer_makro ausfuehrt.<II>syn>II</timer count triggertext : Es wird /def -n%count %triggertext t_timer = /timer trigger erzeugt.@{N}/timer remove : Loescht den Timer.@{N}/timer reset : Setzt den Timer zurueck (geht auch fuer Initalisierung ohne trigger).@{N}/timer get : Liefert in %? die vergangene Zeit.@{N}/timer trigger : Fuehrt den Makro-Body in 'timer_makro' aus, wobei %1 die vergangene Zeit enthaelt.@{N}/timer : Reinitialisiert den Timer und liefert die vergangene Zeit in %? oder als Funktionswert zurueck.<II>ex>II<'/timer 2 -t"*faellt zu Boden*" -mglob' wird zu '/def -n2 -t"*faellt zu Boden*" -mglob t_timer = /timer trigger`<II>var>II<timer, timer_makro<II>see>II<timer_makro<II>trig>II<t_timer<II>type>II<mak<II>fileinfo>II<util.timer.tf<II><I>mstimer>I<<II>info>II<Ein Timer, der im Millisekundenbereich misst, der nur nach einem Patch des TF funktioniert. Beim Anlegen des Mstimers kann ein Trigger definiert werden, der dann den Makro-Body in ?mstimer_makro ausfuehrt.<II>syn>II</mstimer count triggertext : Es wird /def -n%count %triggertext t_mstimer = /mstimer trigger erzeugt.@{N}/mstimer remove : Loescht den Mstimer.@{N}/mstimer reset : Setzt den Mstimer zurueck (geht auch fuer Initalisierung ohne Trigger).@{N}/mstimer get : Liefert in %? die vergangene Zeit.@{N}/mstimer trigger : Fuehrt den Makro-Body in 'mstimer_makro' aus, wobei %1 die vergangene Zeit enthaelt.@{N}/mstimer : Reinitialisiert den Mstimer und liefert die vergangene Zeit in %? oder als Funktionswert zurueck.<II>ex>II<'/mstimer 2 -t"*faellt zu Boden*" -mglob' wird zu '/def -n2 -t"*faellt zu Boden*" -mglob t_mstimer = /mstimer trigger'<II>var>II<mstimer, mstimer_makro<II>see>II<mstimer_makro<II>trig>II<t_mstimer<II>type>II<mak<II>fileinfo>II<util.timer.tf<II><I>util.timer.tf>I<<II>mak>II<timer, mstimer<II>var>II<timer_makro<II>version>II<util.timer.tf,v 1.6 2001/09/12 08:05:51 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Timer in Sekunden und Millisekunden (patched tf)<II>type>II<fileinfo<II>fileinfo>II<util.timer.tf<II><I>trig_purge_timeout>I<<II>info>II<Time to purge alle Triggers defined by a call of trig_grab<II>type>II<var<II>fileinfo>II<util.trigger.tf<II><I>tf_prompt>I<<II>info>II<Zum Erkennen, ob das Mud eine Reihe von Kommandos ausgefuehrt hat, wird das Kommando in %mud_custom_prompt an das Mud geschickt. Dabei kann der Parameter %1 zur Identifizierung benutzt werden. In der Variablen %mud_custom_prompt_response ist die Antwort des Muds enthalten. Dabei wird derselbe Parameter %1 zur Identifizierung genutzt. Nachdem das Kommando ans Mud geschickt wurde, wird der entsprechende Trigger definiert, der als Aktion den als Parameter %2 uebergebenen Text ausfuehrt.<II>syn>II</test tf_prompt(Identifikationstext,Aktion)<II>ex>II</test tf_prompt("Das ist ein Test","/echo Test erfolgreich")<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>def_catch_output_trig>I<<II>info>II<Definiert den Trigger, der das Abfangen der Ausgaben des Muds vornimmt. Das Ergebnis wird in der Variablen %fulldetail gespeichert, wobei die Zeilenumbrueche durch @@@{}{N} gebildet werden. Damit ist eine Nutzung mit /echo2 moeglich. Die Ausgabe des Muds wird unterdrueckt.<II>see>II</catch_output, (alte Namen: /def_psave_trig, /def_psave3_trig)<II>ex>II</set nextmakro=/do_next%;@{N}/set fulldetail=%;@{N}/def_catch_output_trig%;@{N}/catch_output 2%;@{N}unt decke%;unt boden%;<II>var>II<fulldetail<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>catch_ouput>I<<II>info>II<Definiert den Abbruchtrigger (bzw. -hook), der fuer /def_catch_output_trig gilt. Als Paramter kann angegeben werden, wieviele Prompts (Default-Prompt '>') gewartet werden soll (Standard 1). Das Ergebnis des Grabbens wird in der Variablen %fulldetail gespeichert. Es wird anschliessend das in %nextmakro stehende Makro ausgefuehrt, das eine Weiterverarbeitung vornehmen kann.<II>ex>II</set nextmakro=/do_next%;@{N}/set fulldetail=%;@{N}/def_catch_output_trig%;@{N}/catch_output 2%;@{N}unt decke%;unt boden%;<II>syn>II</catch_output [Anzahl der zu wartenden Prompts == Anzahl der Kommandos]<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, /def_catch_2regexp_trig, /catch_output, /def_catch_prefix_trig, /def_catch_regexp_trig, /def_catch_output_trig, (alte Namen: /def_psave_trig, /def_psave3_trig)<II>hook>II<psave2<II>var>II<fulldetail, nextmakro<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>def_catch_regexp_trig>I<<II>info>II<Ein Makro, das einen Regexp-Trigger definiert, dessen aufeinanderfolgende Zeilen in der Variablen %fulldetail gespeichert werden. Dabei wird der Text vom Mud unterdrueckt. Nach einer gegebenen Zeit wird das Grabben beendet und das Makro, welches in der Variablen %nextmakro steht, aufgerufen.<II>ex>II</def_catch_regexp_trig 5 ^Du siehst:@{N}Faengt waehrend der folgenden 5 Sekunden alle Textzeilen ab, die mit 'Du siehst:' beginnen, und speichert sie in der Variablen %fulldetail.<II>syn>II</def_catch_regexp_trig Sekunden Regexp<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, d/ef_catch_2regexp_trig, /catch_output, /def_catch_prefix_trig<II>var>II<%nextmakro, %fulldetail<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>def_catch_2regexp_trig>I<<II>info>II<Der Text, der zwischen den zwei angegebenen Regexp-Triggern (einer fuer Start und einer fuer Stop) erscheint, wird inklusive dieser beiden Zeilen in der Variablen %fulldetail gespeichert. Nach dem Ausfuehren des Stop-Triggers wird das Makro, das in der Variablen %nextmakro steht, ausgefuehrt.<II>ex>II<'/test def_catch_2regexp_trig("^Es begann","^Es endete")' speichert alles zwischen und inklusive der Zeilen der beiden Regexps.<II>syn>II</test def_catch_2regexp_trig(regex_start,regex_stop)<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, /catch_output, /def_catch_prefix_trig, /def_catch_regexp_trig<II>var>II<%nextmakro, %fulldetail<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>def_catch_prefix_trig>I<<II>info>II<Ein Makro, das den Text, in dem die angegebene Regexp auftaucht, fuer eine bestimmte Zeit (Parameter) in der Variablen %fulldetail speichert und nach Ablauf der Zeit das Makro in der Variablen %nextmakro ausfuehrt. Dabei wird nur der Text in der Variablen gespeichert, der nicht von der Regexp abgedeckt wird (PL und PR). Der Text wird gegaggt.<II>ex>II<'/def_catch_prefix_trig 4 Jemand sagt:' speichert dessen Text fuer 4 Sekunden in der Variablen %fulldetail.<II>syn>II</def_catch_prefix_trig Sekunden Regexp<II>see>II</echo2 fuer Ausgabe von Fulldetail mit Zeilenumbruechen, /def_catch_2regexp_trig, /catch_output,  /def_catch_regexp_trig<II>var>II<%nextmakro, %fulldetail<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>def_catch_broken_trig>I<<II>info>II<Faengt einen Text des Muds ab, von dem man nur Anfang und Ende kennen muss und der ueber mehrere Zeilen verteilt sein kann, und laesst den Gesamttext per /trigger nochmal ablaufen, so dass man diesen wie eine Zeile vom Mud betrachten kann.<II>ex>II</test def_catch_broken_trig("Der Haendler meint","Muenzen zahlen")<II>syn>II</test def_catch_broken_trig("Starttext","Endtext")<II>type>II<trig<II>fileinfo>II<util.trigger.tf<II><I>def_catch_num_trig>I<<II>info>II<Nach dem Triggern der Startzeile werden die naechsten n Zeilen in der Variablen %fulldetail gesammelt und dann das Makro in der Variablen %nextmakro ausgefuehrt, das diesen Text dann verarbeiten kann.<II>ex>II<'/def_catch_num_trig 5 Inventory:' sammelt die 5 Zeilen des Inventories auf.<II>syn>II</def_catch_num_trig num_catch_lines Starttext<II>type>II<trig<II>fileinfo>II<util.trigger.tf<II><I>def_catch_tf_prompt_trig>I<<II>info>II<Faengt den Text von der aktuellen Zeile bis zum Auftreten des TF-Prompts ab, das mit dem uebergebenen Text oder default mit def_catch_tf_prompt_trig ausgefuehrt wird. Der gegrabbte Text steht in der Variablen fulldetail<II>syn>II</def_catch_tf_prompt_trig [endtext [tf-code]]<II>ex>II</set nextmakro=/echo \%fulldetail%; /def_catch_tf_prompt_trig%;@{N}oder@{N}/set nextmakro=/echo \%fulldetail%;/def_catch_tf_prompt_trig EndText%;@{N}oder@{N}/def_catch_tf_prompt_trig EndText /echo \%fulldetail%;@{N}oder@{N}/test def_catch_tf_prompt_trig("EndText","/echo \%fulldetail")<II>type>II<trig<II>fileinfo>II<util.trigger.tf<II><I>trig_grab>I<<II>info>II<Grabbt Zeilen aus dem Output des Muds, beginnend mit einer Startzeile (-b) ueber n Zeilen Body (ggf. -y) und eine Endzeile. Das ganze wird durch drei Trigger gesteuert.@{N}Wie kann der eingefangene Text genutzt werden: Entweder es wird per -M ein Makro angegeben, dem der Text nach Abschluss uebergeben wird. Ausserdem wird er in der mit -v angegebenen Variablen (default %fulldetail) gespeichert. Die einzelnen Zeilen werden mit @@@{}{N} (siehe /echo2) oder den bei -d angegebenen Zeichen verkettet. Oder das angegebene Makro wird pro Zeile mit der Zeile aufgerufen (wie bei /quote, daher auch -q).@{N}Abgebrochen wird das Triggering nach einer Anzahl Body-Zeilen (-n), nach einer gewissen Zeit (-t) oder nachdem ein zweites Kommando (-P, mud_custom_prompt) eine weitere Ausgabe im Mud erzeugt hat (%mud_custom_prompt_response). Mit -N kann die Anzahl der Kommandos bestimmt werden, deren Ausgaben eingefangen werden sollen.@{N}Was eingefangen werden soll gibt -c an: b Beginnzeile, y Bodyzeilen, e Endzeile (z.B. -cbye fuer alles inkl. Beginn- und Endzeile).@{N}Wenn die Triggertexte mit einen Praefix beginnen, kann damit der Matching Modus festgelegt werden (r# regexp, g# glob, s# simple).@{N}Mit -C kann ein Kommando angegeben werden, dessen Ausgabe eingefangen werden soll. Alternativ kann dieses auch vor /trig_grab losgeschickt werden.<II>ex>II<@{N}/trig_grab -b"g#*--------" -e"r#^-+$" -M/echo  -q -ag -cbye -Cinfo@{N}faengt die Ausgabe des info Befehls in mg.mud.de ein und gibt sie gleich wieder zeilenweise per /echo aus@{N}/trig_grab -b"g#*--------" -e"r#^-+$" -M/echo -d# -ag -cy -Cinfo@{N}faengt nur den Kern der Info-Ausgabe ein (keine Start und Endtext, siehe -c) und gibt diese per /echo nach erfolgten grabbing als einen Text (Zeilen getrennt durch #, siehe -d) aus)@{N}/trig_grab -e"r#Ausgae?nge?:" -Cschau -M/scan_raum -aCred@{N}faengt die Raumbeschreibung (P_LONG) des aktuellen Raumes ein, faerbt diese rot (-aCred) und uebergibt sie an das eigene Makro /scan_raum als Parameter.<II>opt>II<a Attributes@{N}b Beginning Text syn: [[rgs]#]Text@{N}e Ending Text syn: [[rgs]#]Text@{N}q Quote Mode (def. off)@{N}n Number of Body Lines@{N}N Number of Commands (whose output shall be catched) sent to the Mud (Prompt-Hooks)@{N}E,P Prompt Text Ende@{N}B Prompt Text Beginn@{N}t Time (sec)@{N}v globale Variable name (def. fulldetail)@{N}M callback Macro name (def. none, only the variable is set)@{N}d Line delimeter (def. @@@{}{N})@{N}c Catch Mode ([b][y][e] b beginning y Body e end) (def. y)@{N}y Body Trigger Text (z.B. fuer Praefix) syn: [[rgs]#]Text (def. *)@{N}p Priority@{N}F fallthru triggers or not (def 1)@{N}C Kommando fuers Mud<II>type>II<trig<II>fileinfo>II<util.trigger.tf<II><I>trig_is_active>I<<II>info>II<checks of the triggers defined with trig_grab, whose number was returned by trig_grab are still active or not<II>syn>II</trig_is_active number returned by trig_grab<II>return>II<number of still active triggers/macros (0 to 3)<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>trig_purge>I<<II>info>II<removes the triggers defined with trig_grab, whose number was returned by trig_grab<II>syn>II</trig_purge number returned by trig_grab<II>type>II<mak<II>fileinfo>II<util.trigger.tf<II><I>util.trigger.tf>I<<II>mak>II<tf_prompt, def_catch_output_trig, catch_ouput, def_catch_regexp_trig, def_catch_2regexp_trig, def_catch_prefix_trig, trig_is_active, trig_purge<II>trig>II<def_catch_broken_trig, def_catch_num_trig, def_catch_tf_prompt_trig, trig_grab<II>var>II<trig_purge_timeout<II>version>II<util.trigger.tf,v 1.21 2001/12/05 21:25:45 nieten (Mesirii@mg.mud.de)<II>req>II<<II>info>II<verschiedene Trigger, die mehrere Zeilen grabben<II>type>II<fileinfo<II>fileinfo>II<util.trigger.tf<II><I>world_local>I<<II>info>II<Hilfsfunktionen zum Verwalten von Variablen, die nur lokal fuer eine Welt zustaendig sind.<II>mak>II<setw, getw, listw, unsetw, echow<II>type>II<see<II>fileinfo>II<util.vfunc.tf<II><I>setw>I<<II>info>II<Setzt die Variable ${world_name}_%1 auf den uebergebenen Wert. Nutzung ohne =<II>mak>II<getw, listw, unsetw, echow<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>getw>I<<II>info>II<Liefert den Wert der mit /setw gesetzten Variablen als Funktionsrueckgabewert oder in %?.<II>mak>II<setw, listw, unsetw, echow<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>listw>I<<II>info>II<Listet alle Variablen auf, die lokal fuer diese Welt gesetzt sind.<II>mak>II<setw, unsetw, echow, getw<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>unsetw>I<<II>info>II<Loescht die Variable ${world_name}_%1, die mit /setw auf einen Wert gesetzt wurde.<II>mak>II<getw, listw, setw, echow<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>echow>I<<II>info>II<Gibt die angegebene Variable, die lokal fuer die aktuelle Welt gesetzt wurde, aus und gibt sie gleichzeitig als Funktionswert bzw. in %? zurueck.<II>mak>II<getw, listw, setw, unsetw<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>inner_var>I<<II>info>II<Erlaubt den Zugriff auf beliebig tief aufeinander verweisende Variablen (z.B. a2="a1" a1="a0" a0=5).<II>syn>II</inner_var [tiefe] varname<II>ex>II<a2="a1" a1="a0" a0=5@{N}/inner_var a2 -> "a1"@{N}/inner_var 1 a2 -> "a1"@{N}/inner_var 2 a2 -> "a0"@{N}/inner_var 3 a2 -> "5"<II>type>II<func<II>fileinfo>II<util.vfunc.tf<II><I>find_usages>I<<II>info>II<Listet alle Verwendungen des angegebenen Strings (Variable, Makroname) in allen Makros, die dem vorgegebenen Suchmuster (fuer list) entsprechen.<II>syn>II</find_usages varname [List Pattern]<II>ex>II</find_usages addtolist *find*@{N}/find_usages wecho_attr<II>return>II<per /result und in find_usage_list<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>find_usages_add_name>I<<II>info>II<Fuegt alles ab dem 3. Parameter der Variablen %find_usage_list hinzu.<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>init_var>I<<II>info>II<Initialisiert die uebergebenen Variablen als globale Variablen, wenn sie noch nicht gesetzt sind; wenn sie schon gesetzt sind, bleiben sie unberuehrt.<II>type>II<mak<II>fileinfo>II<util.vfunc.tf<II><I>util.vfunc.tf>I<<II>see>II<world_local<II>mak>II<setw, getw, listw, unsetw, echow, find_usages, find_usages_add_name, init_var<II>func>II<inner_var<II>version>II<util.vfunc.tf,v 1.11 2001/10/08 17:49:20 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Variablenfunktionen, isVar, purge_vars, World lokal Variablen<II>type>II<fileinfo<II>fileinfo>II<util.vfunc.tf<II><I>add_to_window_r>I<<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Regexp-Trigger geschrieben, aber trotzdem noch im normalen Fenster angezeigt.<II>ex>II</add_to_window_r Tod \\[Tod:.*<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>move_to_window_r>I<<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Regexp-Trigger geschrieben, aber wird nicht mehr im normalen Fenster angezeigt.<II>ex>II</move_to_window_r Tod \\[Tod:.*<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>add_to_window_g>I<<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Global-Trigger geschrieben, aber trotzdem noch im normalen Fenster angezeigt.<II>ex>II</add_to_window_g Tod *[Tod:*<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>move_to_window_g>I<<II>info>II<In das als erster Parameter angegebene Fenster werden die vom als Rest angegebenen Global-Trigger geschrieben, aber wird nicht mehr im normalen Fenster angezeigt.<II>ex>II</move_to_window_g Tod *[Tod:*<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>write_to_window>I<<II>info>II<In das als erster Parameter angegebene Fenster wird der als Restparameter uebergebene Text geschrieben.<II>ex>II</write_to_window Tod wieder mal gestorben<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>show_window>I<<II>info>II<Zeigt das als Parameter angebegene Fenster an (falls es geschlossen wurde).<II>ex>II</show_window Tod<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>get_window_file>I<<II>info>II<liefert den Dateinamen fuer das Logging dieses windows zurueck<II>type>II<mak<II>fileinfo>II<util.windows.tf<II><I>remove_window>I<<II>info>II<Loescht alle Trigger fuer das angegeben Fenster und schliesst das zugehoerige File<II>type>II<comm<II>fileinfo>II<util.windows.tf<II><I>windows_run_timestamps>I<<II>info>II<Erzeugt den Hook um aller windows_timestamp_interval_min einen Zeitstempel in jedes Log zu schreiben<II>see>II<windows_stop_timestamps<II>type>II<mak<II>fileinfo>II<util.windows.tf<II><I>windows_stop_timestamps>I<<II>info>II<Setzt die Variable windows_run_timestamps auf 0<II>type>II<mak<II>fileinfo>II<util.windows.tf<II><I>window_timestamps>I<<II>info>II<Funktion die an eine Beat-Hook gehaengt wird um Timestamps in alle Logs zu schreiben, das geschieht nur wenn man eine aktive world hat und die Variable windows_run_timestamps auf 1 steht.<II>see>II<windows_run_timestamps<II>type>II<mak<II>fileinfo>II<util.windows.tf<II><I>util.windows.tf>I<<II>comm>II<add_to_window_r, move_to_window_r, add_to_window_g, move_to_window_g, write_to_window, show_window, remove_window<II>mak>II<get_window_file, windows_run_timestamps, windows_stop_timestamps, window_timestamps<II>version>II<util.windows.tf,v 1.11 2002/02/09 15:19:56 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf<II>info>II<gezieltes Umleiten von Mudausgaben in Dateien und andere Fenster<II>type>II<fileinfo<II>fileinfo>II<util.windows.tf<II><I>setos>I<<II>info>II<Setzt die Variable OS auf das verwendete Betriebssystem (bisher 'win' und 'linux').<II>var>II<OS<II>type>II<mak<II>fileinfo>II<util.tf<II><I>showchars>I<<II>info>II<Zeigt die Dezimal, Hexcodes und die Character der Zeichen von 20 bis 127 an.<II>type>II<mak<II>fileinfo>II<util.tf<II><I>artikel_entfernen>I<<II>info>II<Entfernt einen bestimmten bzw. unbestimmten Artikel vom Parameter, unter Nutzung von regmatch.<II>ex>II</artikel_entfernen Ein NPC - return NPC<II>type>II<mak<II>fileinfo>II<util.tf<II><I>wecho>I<<II>info>II<Schaltet ein Echo der zum Mud gesendten Kommandos ein und aus. Falls kein Parameter uebergeben wurde, wird die jeweils andere Einstellung verwendet. Wird '0' bzw. '1' als Parameter uebergeben, wird das Echo unabhaengig von der alten Einstellung. aus- bzw. eingeschaltet. Das Echo wird mit dem in 'wecho_attr' angegebenen Attributen ausgegeben.<II>var>II<wecho<II>see>II<wecho_attr<II>syn>II</wecho [0|1]<II>type>II<comm<II>fileinfo>II<util.tf<II><I>test_quiet>I<<II>info>II<Mit der Variablen 'wecho_attr' koennen Attribute und Farbe des von /wecho ausgegeben Echos festgelegt werden. Die Aenderung wird erst nach '/wecho 1' bzw. zweimaligem '/wecho' wirksam.<II>see>II</wecho<II>var>II<wecho_attr<II>info>II<Fuehrt den uebergebenen String per /test aus, speichert ggf. vorhandene Ausgaben in der Variablen 'output' und gibt per /return das Ergebnis des ausgefuehrten Strings zurueck.<II>ex>II</test_quiet /list -s makroname@{N}In 'output' stehen alle gefundenen Makros oder nichts.@{N}Der Rueckgabewert ist der vom /list.<II>var>II<output<II>type>II<mak<II>fileinfo>II<util.tf<II><I>nop>I<<II>info>II<Kommando, das nichts tut. Es ist notwendig, weil '%;' als Body eines Makros ein Newline ans Mud sendet.<II>type>II<mak<II>fileinfo>II<util.tf<II><I>min>I<<II>info>II<Liefert das Minimum von zwei Zahlenwerten ueber /echo zurueck. Also Ergebnis mit $() holen.<II>return>II<ueber /echo das Minimum der Zahlen<II>see>II<substitutions<II>type>II<mak<II>fileinfo>II<util.tf<II><I>max>I<<II>info>II<Liefert das Maximum von zwei Zahlenwerten ueber /echo zurueck. Also Ergebnis mit $() holen.<II>return>II<ueber /echo das Maximum der Zahlen<II>see>II<substitutions<II>type>II<mak<II>fileinfo>II<util.tf<II><I>lazym>I<<II>info>II<Lazy Call im Makrokontext. Es wird erst gecheckt, ob das Makro existiert, bevor es mit seinen Parametern ausgefuehrt wird. Falls es nicht existiert, wird mit /debug eine Fehlermeldung erzeugt.<II>ex>II</lazym foo bar -> /foo bar oder Not Found foo<II>syn>II</lazym makroname parameters<II>type>II<mak<II>fileinfo>II<util.tf<II><I>lazyf>I<<II>info>II<Lazy Call im Funktionskontext. Es wird erst gecheckt ob die Funktion existiert, bevor sie mit ihren Parametern ausgefuehrt wird. Falls sie nicht existiert, wird mit /debug eine Fehlermeldung erzeugt.<II>ex>II</test lazyf("foo",bar) -> /test foo(bar) oder Not Found foo<II>syn>II</test lazyf("makroname",parameter..)<II>type>II<mak<II>fileinfo>II<util.tf<II><I>_read>I<<II>info>II<Ersatz fuer read(), das durch 'tfread' ersetzt wurde. Noetig, wenn die Eingabe direkt weiterverwendet werden soll, z.B. in einer regexp.<II>ex>II</echo /_read @{N} /if (_read() =~ "test") ...<II>return>II<die Eingabe<II>see>II<tfread, read<II>type>II<mak<II>fileinfo>II<util.tf<II><I>make_dos_path>I<<II>info>II<konvertiert einen CygWin Path in einen Dos Pfad<II>type>II<info<II>fileinfo>II<util.tf<II><I>shread>I<<II>info>II<Ersetzt read, tfread, _read in asynchronen Makros. Es ist ein boeser Workaround, der mit dem Shellscript 'tfread' arbeitet, das in dem Verzeichnis %makdir liegen muss. Ansonsten funktioniert es wie das normale /read. Der gelesene Wert steht ausserdem in 'read_value'.<II>return>II<der eingelesene Wert.<II>syn>II</shread Prompttext<II>hook>II<hresume_shread<II>var>II<read_value, makdir<II>mak>II<sh, load<II>type>II<mak<II>fileinfo>II<util.tf<II><I>killall>I<<II>info>II<Killt alle Prozesse, die den uebergebenen Parameter enthalten<II>opt>II<q keine Ausgabe beim Kill<II>syn>II</killall [-q] matchtext<II>ex>II</repeat -10 10 /echo foo%;/killall foo<II>type>II<mak<II>fileinfo>II<util.tf<II><I>kill_process>I<<II>info>II<wird von killall genutzt um den Prozess zu matchen und zu toeten<II>syn>II<kill_process matchtext single line from ps<II>type>II<mak<II>fileinfo>II<util.tf<II><I>xtitle>I<<II>info>II<Setzt den Titel des xterms.<II>type>II<comm<II>fileinfo>II<util.tf<II><I>vlines>I<<II>info>II<Anzahl der sichtbaren Ausgabezeilen<II>type>II<func<II>fileinfo>II<util.tf<II><I>rename_mac>I<<II>info>II<Benennt ein Makro um bzw. erstellt eine Kopie davon. Damit wird sichergestellt, dass die Probleme mit Parametern nicht auftreten (Leerzeichenverlust bei Makros, auf neun begrenzte Parameteranzahl fuer Funktionen).@{N}Das soll genutzt werden, um Kommandos aus den Namespaces der Files in benutzerfreundliche Namen umzuwandeln.@{N}Wird ein dritter Parameter uebergeben, so wird die Umbennung in der Variablen %renamed_list_<Paramter 3> gespeichert. Will man nun die Makros eines Pakets vollstaendig entfernen, so lassen sich mit ?/purge_renamed auch die Kopien der Makros loeschen.<II>syn>II</rename_mac neuer_name alter_name [paketname]<II>ex>II</rename_mac wo ways_where ways<II>see>II</purge_renamed<II>mak>II</createnewlist, /uaddtolist<II>type>II<comm<II>fileinfo>II<util.tf<II><I>purge_renamed>I<<II>info>II<Dem Makro wird ein Paketname uebergeben, woraufhin alle Makros, die in der Variablen %renamed_list_<Paketname> stehen, mittels /purge geloescht werden. Diese Funktion ist in Verbindung mit ?/rename_mac dazu gedacht, das vollstaendige Entfernen von Paketen zu erleichtern und trotzdem die Moeglichkeit zu erhalten, Makros z. B. laenderspezifische Namen zu geben. Ein Makro zum Entfernen des Paktes comm.tf koennte dann so aussehen:@{N}/def comm_remove = \@{N}@{n}    /purge -mglob comm_*%;\@{N}@{n}    /purge_renamed comm%;\@{N}@{n}    ...@{N}(Einfacher geht's natrlich mit "/remove_packet comm".)<II>syn>II</purge_renamed ways<II>see>II</rename_mac, /remove_packet<II>ex>II<Nach@{N}/rename_mac wo ways_where ways@{N}/rename_mac gehe go ways@{N}/rename_mac keine_portale noport ways@{N}wuerde@{N}/purge_renamed ways@{N}die Makros /wo, /gehe und /keine_portale loeschen.<II>mak>II</forEach<II>type>II<comm<II>fileinfo>II<util.tf<II><I>remove_packet>I<<II>info>II<Dieses Makro hilft beim vollstaendigen Entfernen aller Makros, Trigger, Hooks, Variablen eines Pakets. Es werden mittels /purge alle Makros, Trigger und Hooks geloescht, die mit dem angegeben Praefix (ein '_' wird dahinter ergaenzt) beginnen. Ausserdem wird das Makro /remove_<Praefix> geloescht. Desweiteren werden alle mit ?/rename_mac erstellten Kopien dieser Makros geloescht, sofern beim Aufruf von /rename_mac das entsprechende Praefix mit uebergeben wurde. Schliesslich werden noch alle mit dem Praefix beginnende Variablen geloescht. Ausser dem Praefix koennen noch Makro- und/oder Variablennamen uebergeben werden, die dann ebenfalls mit /purge bzw. /unset geloescht werden.<II>syn>II</remove_packet praefix [weitere Makro-/Variablennamen]<II>ex>II<Der Aufruf von@{N}/remove_packet comm rufe last_partner@{N}loescht alle Makros, Trigger, Hooks und Variablen, die mit "comm_" beginnen, sowie das Makro /rufe, die Variable %last_partner und /remove_comm.@{N}Wurde vorher mit@{N}/rename_mac tmh comm_tm_hist comm@{N}das Makro /comm_tm_hist kopiert, so loescht das obige /remove_packet auch /tmh.<II>see>II</purge_renamed, /rename_mac<II>mak>II</purge_renamed<II>type>II<comm<II>fileinfo>II<util.tf<II><I>util.tf>I<<II>info>II<Enthaelt Makros und Kommandos, die immer wieder gebraucht werden, die aber unabhaengig vom Mud sind. Alle Makros sind sehr nuetzlich auch fuer den gelegentliche Nutzer.<II>over>II<dc, quit<II>list>II<${world_character}tosave, ${world_character}saved, tosave<II>var>II<echolist, loadall, wecho<II>changes>II<0.00 /echo2 zur Ausgabe von Newlines mit einem /echo.@{N}1.00 /completion und Stack (/push, /pop).@{N}/timer zum Zeitmessen im Sekundenbereich.@{N}1.01 /myread fuer Keyboardeingaben von asynchronen Makros.@{N}/tokenize fuer das Aufspalten von Strings.@{N}1.02 /shread als funktionierenden Workaround fuer das Read in asynchronen Makros.@{N}1.04 Fuer /shread ist jetzt auch ein Binary fuer Windows vorhanden, deshalb musste auch der Dateiname der Ergebnisdatei auf 8+3 angepasst werten.@{N}Hilfsfunktionen fuer die Nutzung world-lokaler Variablen hinzugefuegt (siehe ?world_local).@{N}Die Trigger zum Auslesen der Mudausgabe eines oder mehrerer Kommandos wurden in 'util.tf' verschoben (siehe /catch_output).@{N}1.05 Die Funktionen zum Umleiten von Mudausgaben in andere Fenster sowie die Ersetzung von Abkuerzungen in gesendetem Text wurden von der ${world_host}/comm.tf in die util.tf verschoben, da sie nicht mudspezifisch sind.@{N}/wecho etwas erweitert.<II>hook>II<CONNECT, DISCONNECT, SIGHUP<II>info>II<make_dos_path<II>comm>II<wecho, xtitle, rename_mac, purge_renamed, remove_packet<II>mak>II<setos, showchars, artikel_entfernen, test_quiet, nop, min, max, lazym, lazyf, _read, shread, killall, kill_process<II>func>II<vlines<II>version>II<util.tf,v 1.20 2001/12/03 12:57:52 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf<II>type>II<fileinfo<II>fileinfo>II<util.tf<II><I>make_help>I<<II>info>II<Wird von /mload beim Laden eines Files aufgerufen. Es werden die Variable 'file_name' gesetzt und<II>type>II<comm<II>fileinfo>II<help.tf<II><I>help_keywords>I<<II>info>II<Enthaelt die moeglichen Schluesselworte fuer die Hilfebefehle.<II>ex>II<mak(key) 1 Makros:(value, 0|1|2 Detailstufe, Ueberschrift)<II>type>II<list<II>fileinfo>II<help.tf<II><I>addh>I<<II>info>II<Ermoeglicht es, neue Eintraege in das Hilfesystem einzufuegen. Dazu werden zuerst die gewuenschten Rubriken gefuellt und danach alle in die Hilfe eingetragen. Bei den Texten koennen alle von /echo -p bekannten Formatierungen benutzt werden und ausserdem noch @@@{}{N} fuer Zeilenumbrueche.@{N}(Mit @@{} am Zeilenanfang koennen uebrigens fuehrende Leerzeichen erzeugt werden.)<II>syn>II</addh info|syn|var|list|return|mak|comm|ex|see Text mit Formatierungen@{N}und zum Schluss: /addh eintrag<II>list>II<help, helpindex, addh_sublist, help_keywords<II>see>II<help, echo, echo2<II>type>II<mak<II>fileinfo>II<help.tf<II><I>addh_fileinfo>I<<II>info>II<Fuegt die in dieser Makrodatei erstellten Kommandos und Makros in den Hilfeeintrag fuer die Datei ein und schliesst diesen Hilfeeintrag ab.<II>var>II<fi_list, file_name<II>mak>II<forEach, addh, fi_add<II>list>II<file_comm, file_mak<II>type>II<mak<II>fileinfo>II<help.tf<II><I>fi_add0>I<<II>info>II<Hilfsmakro, das die einzelnen Teillisten oder Subtopics eines Eintrags in die Hilfeliste schreibt.<II>var>II<temp_list, fi_list, help_list_%help_keywords<II>mak>II<forEach, addh, fi_add<II>type>II<mak<II>fileinfo>II<help.tf<II><I>fi_add>I<<II>info>II<Haengt Parameter an Variable %fi_list an.<II>var>II<fi_list<II>type>II<mak<II>fileinfo>II<help.tf<II><I>defh>I<<II>info>II<Erzeugt Makros, die mit den Parametern '-h' und '-?' ihren entsprechenden Hilfetext darstellen. Das sollten @{B}alle interaktiven Makros@{n} sein.<II>see>II<def, help<II>type>II<mak<II>fileinfo>II<help.tf<II><I>hilfe>I<<II>info>II<Falls vorhanden zeigt es den Hilfetext fuer den angegebenen Parameter an. Mit einem vorangestellten '+' wird eine ausfuehrliche Hilfe angezeigt. Ansonsten gibt es den Parameter an das tf-Hilfesystem weiter.<II>syn>II</hilfe [+][/]eintrag<II>list>II<helpindex, help, addh_sublist<II>see>II<addh, defh<II>var>II<addh_sublist<II>type>II<comm<II>fileinfo>II<help.tf<II><I>make_help_html>I<<II>info>II<Erzeugt alle Hilfe-Datein als HTML in den Verzeichnissen '%makdir/help/global' fuer den Normaluser und '%makdir/help/expert' fuer den Programmierer<II>mak>II</tokenize, /make_html_file<II>var>II<%makdir<II>type>II<misc<II>fileinfo>II<help.tf<II><I>make_html_file>I<<II>info>II<Erzeugt ein HTML-Hilfefile aus dem uebergebenen Hilfeeintrag, moeglichst eine Makrodatei, aber auch ein einzelnes Kommando ist moeglich. An den uebergebenen Namen wird ein .html angehaengt. Es werden auch die in der Hilfebeschreibung referenzierten im selben File definierten Makros mit auf die Seite gepackt. Ein '+' vor dem Namen erzeugt eine Entwicklerversion (ausfuehrlicher).<II>syn>II</make_html_file [+]macro(datei)<II>var>II<html_eval_list, html_full,<II>comm>II<hilfe_html<II>func>II<tfio<II>type>II<comm<II>fileinfo>II<help.tf<II><I>hilfe_html>I<<II>info>II<Gibt per /echo eine HTML-Version der Onlinehilfe fuer einen Hilfeeintrag aus.<II>see>II<hilfe, make_html_file<II>mak>II<forEach, show_help_html<II>list>II<addh_sublist, help_keywords<II>var>II<html_full, html_file_name,<II>comm>II<help<II>type>II<comm<II>fileinfo>II<help.tf<II><I>show_help>I<<II>info>II<Zeigt die einzelnen Rubriken eines Hilfethemas an. Dabei ist der komplette Eintrag in der Liste 'addh_sublist' enthalten.<II>syn>II</show_help 0|1 Hilfeschluesselwort 0|1 Titel<II>list>II<addh_sublist<II>mak>II<echo2, getvalueof<II>type>II<mak<II>fileinfo>II<help.tf<II><I>show_help_html>I<<II>info>II<Zeigt die einzelnen Rubriken eines Hilfethemas als HTML-Quelltext an. Dabei ist der komplette Eintrag in der Liste 'addh_sublist' enthalten.<II>syn>II</show_help_html 0|1 Hilfeschluesselwort 0|1 Titel<II>list>II<addh_sublist,<II>mak>II<echo2, getvalueof<II>type>II<mak<II>fileinfo>II<help.tf<II><I>tf_html>I<<II>info>II<Pfad zu tf-Hilfe HTML-Seiten.<II>ex>II<tf_html=file://localhost/data/docs/tf/commands/index.html<II>type>II<var<II>fileinfo>II<help.tf<II><I>make_hrefs>I<<II>info>II<Scannt uebergebene Strings nach potentiellen Links und erzeugt diese, Parameteruebergabe in %value.<II>return>II<in %value der modifizierte String<II>var>II<html_file_name, html_eval_list, value<II>list>II<help_keywords, help<II>comm>II<help<II>type>II<mak<II>fileinfo>II<help.tf<II><I>help.tf>I<<II>info>II<Enthaelt die fuer das Hilfesystem notwendigen Befehle. Die Hilfetexte werden in den Listen 'help' und 'helpindex' abgespeichert.<II>list>II<help, helpindex, addh_sublist, help_keywords<II>tut>II<Die Benutzung in den eigenen Files ist ganz einfach:@{N}Diese Schluesselworte koennen verwendet und natuerlich auch erweitert werden:@{N}@{N}info 0 Info:@{N}syn 0 Syntax:@{N}misc 0 Sonstiges:@{N}adapt 1 Anpassen an Mud:@{N}ex 0 Beispiel:@{N}return 1 Rueckgabewert:@{N}see 0 Siehe auch:@{N}comm 0 Kommandos:@{N}mak 1 Makros:@{N}hook 1 Hooks:@{N}trig 1 Trigger:@{N}over 1 TF-Befehle:@{N}func 1 TF-Funktionen:@{N}var 1 Variablen:@{N}list 1 Listen:@{N}fileinfo 0 Datei:@{N}type 2 Typ:@{N}@{N}@{N}Ein Hilfeeintrag sieht z.B. so aus:@{N}@{N}/addh info \@{N}Holt eine/viele Variable aus dem Stack. Wenn Variablenname(n) uebergeben werden, wird der Wert in dieser Variablen gespeichert.@{N}/addh ex /pop@@@{}{N}\@{N} /pop test@@@{}{N}\@{N} /pop test test2@{N}/addh return der Inhalt der letzten Variablen@{N}/addh see push, getstack, putstack@{N}/addh pop mak@{N}@{N}@{N}Die Hilfe im tf sieht dann so aus:@{N}@{N}@{B}Makros: pop@{n}@{N}@{B}Info:@{n} Holt eine/viele Variable aus dem Stack. Wenn Variablenname(n) uebergeben @{N}werden, wird der Wert in dieser Variablen gespeichert.@{N}@{B}Beispiel:@{n} /pop@{N}/pop test@{N}/pop test test2@{N}@{B}Siehe auch:@{n} push, getstack, putstack@{N}@{B}Datei:@{n} util.tf@{N}@{N}Aus der Hilfe koennen dann auch HTML-Seiten erzeugt werden. Durch eine Angabe am Ende der Files kann eine Zusammenfassung fuer das Makrofile erzeugt werden.@{N}Da die Erzeugung der Hilfeinformationen nur auf Wunsch geschieht, sind die Ladezeiten ansonsten kaum beeinflusst.@{N}Es gibt eine Moeglichkeit, Makros mit /defh zu definieren, so dass sie interaktiv Hilfe liefert. Z.B. zeigt "/showway -?" oder "/showway -h" den Hilfeeintrag an.<II>misc>II<make_help_html<II>comm>II<make_help, hilfe, make_html_file, hilfe_html<II>mak>II<addh, addh_fileinfo, fi_add0, fi_add, defh, show_help, show_help_html, make_hrefs<II>var>II<tf_html<II>list>II<help_keywords<II>version>II<help.tf,v 1.16 2001/12/14 00:57:32 nieten (Mesirii@mg.mud.de)<II>req>II<!lists.tf util.sfunc.tf util.echo.tf util.hooks.tf<II>type>II<fileinfo<II>fileinfo>II<help.tf<II><I>einfuehrung>I<<II>info>II<Eine Einfuehrung als solche gibt es nicht, bitte die Hilfeseite zum Dateisystem mit "/hilfe loading.tf" anschauen und dann von dort weiter verzweigen.<II>see>II<loading.tf<II>type>II<see<II>fileinfo>II<help.tf<II><I>properties>I<<II>info>II<Die Properties enthalten alle moeglichen Werte des Spielers. Man kann sie sich am besten mit /who[ami] oder /who is name anzeigen lassen.@{N}Sie werden bei den Einschraenkungen der Wege verwandt und um spieler- bzw. gildenspezifische Makrodateien zu laden.<II>see>II<wege, dateisystem, mud_properties<II>comm>II<whoami, who<II>type>II<see<II>fileinfo>II<properties.tf<II><I>whoami>I<<II>info>II<Zeigt die eigenen Properties an.<II>see>II<properties<II>comm>II<who<II>type>II<comm<II>fileinfo>II<properties.tf<II><I>who>I<<II>info>II<Zeigt entsprechend der Parameter die Properties an.@{N}'/who am i' zeigt die eigenen Properties an.@{N}'/who is name' zeigt die Properties des Spielers an.<II>syn>II</who [am i|is name]<II>type>II<comm<II>fileinfo>II<properties.tf<II><I>properties.tf>I<<II>info>II<Enthaelt die mudunabhaengigen Makros die Properties betreffend.<II>req>II<lists.tf, loading.tf, util.tf<II>changes>II<Die Properties werden nun im Spielerverzeichnis gesichert. Aus Kompatibilitaetsgruenden wird beim Laden aber auch (noch) im Mud-Verzeichnis gesucht.<II>see>II<mud_properties, properties<II>see>II<properties<II>comm>II<whoami, who<II>version>II<properties.tf,v 1.11 2001/11/27 21:35:21 mh14 (Mesirii@mg.mud.de)<II>req>II<!lists.tf util.sfunc.tf util.trigger.tf<II>type>II<fileinfo<II>fileinfo>II<properties.tf<II><I>myconn>I<<II>info>II<Beim Connect wird einmalig die Datei ${world_host}/${world_character} geladen.Ausserdem werden die mittels /saveall abgespeicherten Variablen mit /loadsaved wieder geladen.<II>mak>II<saveall, loadsaved<II>hook>II<CONNECT<II>type>II<hook<II>fileinfo>II<worldconnect.tf<II><I>reconnect>I<<II>info>II<Beendet die Verbindung zur aktuellen Welt und baut sofort eine neue auf.<II>syn>II</reconnect [world]<II>type>II<comm<II>fileinfo>II<worldconnect.tf<II><I>mydc>I<<II>info>II<Speichert bei einem Disconnect die angegebenen Variablen.<II>see>II<addsave, loadsaved, saveall<II>hook>II<SIGHUP, DISCONNECT<II>type>II<hook<II>fileinfo>II<worldconnect.tf<II><I>quit>I<<II>info>II<Ueberschreibt das standardmaessige /quit so, dass die angegebenen Variablen abgespeichert werden. Der Hook quit wird ausserdem ausgefuehrt.<II>see>II<loadsaved, saveall, addsave, lists.mak<II>type>II<over<II>fileinfo>II<worldconnect.tf<II><I>loadsaved>I<<II>info>II<Laedt die in der letzten Sitzung gespeicherten Variablen aus der Datei ${world_character}saved.list im Verzeichnis ${world_host}/${world_character}. Falls diese Datei nicht existiert, wird versucht, sie aus ${world_host} zu laden. (Dieser zweite Versuch wird nur aus Kompatibilitaetsgrunden durchgefuehrt und in zukuenftigen Versionen vermutlich rausfliegen.)<II>list>II<${world_character}saved<II>see>II</addsave, /saveall<II>changes>II<Defaultverzeichnis ist nun ${world_host}/${world_character}.<II>type>II<comm<II>fileinfo>II<worldconnect.tf<II><I>addsave>I<<II>info>II<Fuegt die als Parameter angegebene Variable zu einer Liste hinzu, damit sie spaeter mit abgespeichert wird.<II>list>II<${world_character}tosave<II>see>II<loadsaved, saveall<II>var>II<tosave, _temp<II>type>II<comm<II>fileinfo>II<worldconnect.tf<II><I>saveall>I<<II>info>II<Speichert alle in der Liste angegebenen Variablenwerte in ${world_character}saved.list im Verzeichnis ${world_host}/${world_character} bzw. speichert die angegebenen Listen in ihre entsprechenden Dateien.<II>list>II<${world_character}tosave<II>see>II</addsave, /loadsaved<II>changes>II<Wird nun in ${world_host}/${world_character} gespeichert.<II>type>II<comm<II>fileinfo>II<worldconnect.tf<II><I>worldconnect.tf>I<<II>comm>II<reconnect, loadsaved, addsave, saveall<II>hook>II<myconn, mydc<II>over>II<quit<II>version>II<worldconnect.tf,v 1.10 2002/03/27 01:31:35 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf util.hooks.tf util.prompts.tf<II>info>II<Speichern und Laden von Variablen, Connection mit automatischen Laden von Files<II>type>II<fileinfo<II>fileinfo>II<worldconnect.tf<II><I>keys_dmode>I<<II>info>II<Flag fuer Display Mode (Anzeigen der Tastenbelegung bei Tastendruck, statt Ausfuehrung)<II>syn>II<0 aus 1 ein<II>type>II<var<II>fileinfo>II<keys.tf<II><I>tasten_slist>I<<II>info>II<wenn diese Variable auf 1 gesetzt ist, wird die Liste bei jeder Aenderung gespeichert.<II>list>II<tasten<II>type>II<var<II>fileinfo>II<keys.tf<II><I>tasten>I<<II>info>II<Die Liste tasten enthaelt alle Tastenbelegungen. Sie ist sozusagen die zentrale Datenbank.<II>type>II<list<II>fileinfo>II<keys.tf<II><I>addlist>I<<II>info>II<Intern. Fuegt eine Belegung ohne weitere Ueberpruefung in die Liste ein.<II>list>II<tasten<II>see>II<setkey<II>syn>II</addlist modus nummer befehl kommentar@{N}alternativ Befehl und Kommentar mit Leerzeichen:@{N}/addlist modus nummer befehl parameter&kommentar text<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>setkey>I<<II>info>II<legt eine Tastenbelegung fest.<II>syn>II</setkey Modus Taste Befehl Beschreibung@{N}Befehl und/oder Beschreibung mit Leerzeichen@{N}/setkey Modus Taste Befehl&Beschreibung<II>ex>II</setkey 2 5 i Inventory@{N}/setkey 2 5 zuecke %waffe&Waffe zuecken<II>list>II<tasten<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>selectlastmode>I<<II>info>II<Intern. Waehlt die letzte Belegung, in der Tasten eingetragen sind.<II>syn>II</selectlastmode<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>delkey>I<<II>info>II<loescht eine eingetragene Tastenbelegung wieder.<II>syn>II</delkey Belegung Taste<II>list>II<tasten<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>setdesc>I<<II>info>II<legt eine Beschreibung fuer einen der neun Modi fest.<II>syn>II</setdesc Modus Beschreibung<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>getdesc>I<<II>info>II<liefert die Beschreibung eines Modus zurueck.<II>syn>II</getdesc Modus<II>return>II<Beschreibung<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>gettdesc>I<<II>info>II<liefert die Beschreibung fuer eine Tastenbelegung zurueck.<II>syn>II</gettdesc Modus Taste<II>return>II<Beschreibung<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>gettcmd>I<<II>info>II<liefert den Befehl fuer eine Tastenbelegung zurueck.<II>syn>II</gettcmd Modus Taste<II>return>II<Beschreibung<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>key_press>I<<II>info>II<Funktion die bei Tastendruck aufgerufen wird, wenn Display Modus (%keys_dmode) eingeschaltet ist wird die Belegung dargestellt, ansonsten der Befehl ausgefuehrt<II>syn>II</key_press belegung key<II>see>II<keys_dmode<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>keys_set_bindings>I<<II>info>II<Setzt die Standardkeybindings (ESC 0-9 und F1-F12) fuer keys<II>type>II<mak<II>fileinfo>II<keys.tf<II><I>keys.tf>I<<II>info>II<@{N}Mehrfach-Tastenbelegungen.@{N}ermoeglicht, die F-Tasten mehrfach zu belegen, und durch einfache Tastenkombinationen zwischen den Belegungen hin- und herzuschalten.<II>see>II<setkey, delkey, setdesc, set_mode<II>tut>II<Hilfe zur Tastenbelegung gibt es mit Esc-0@{N}@{N}Die Funktionen@{N}Esc-0     zeigt die F-Tasten-Belegung im aktuellen Modus an@{N}Esc-<x>   wechselt auf Modus 1-9@{N}Esc-d     schaltet den Display-Modus an/aus. Im Display-Modus@{N}werden nur Befehl und Beschreibung angezeigt.@{N}@{N}/setkey <b> <t> <befehl> <beschreibung>@{N}setzt fuer die Taste F<t> im Modus <b> den Befehl <befehl>@{N}Die Beschreibung wird auf <beschreibung> gesetzt.@{N}Beispiel: /setkey 1 4 /ladestab Stab laden@{N}(wenn Modus 1 aktiv ist (Esc-1), dann bewirkt ein@{N}Druck auf F4, dass "/ladestab" ausgefuehrt wird.@{N}In der Uebersicht (Esc-0) wird "Stab laden" angezeigt.)@{N}bisher nur Befehle aus einem Wort moeglich.@{N}@{N}/delkey <b> <t>@{N}loescht den Befehl fuer die Taste F<t> im Modus <b>@{N}Beispiel: /delkey 1 4@{N}(macht o.g. Beispiel rueckgaengig)@{N}@{N}/setdesc <b> <beschreibung>@{N}setzt die Beschreibung fuer den Modus <b>.@{N}@{N}/set_mode <i>|<desc>@{N}schaltet auf den Modus mit der Nummer i oder mit der@{N}Beschreibung desc um (letzteres noch nicht implementiert!)<II>var>II<tasten_slist Wenn auf 1 gesetzt, wird die Liste bei jeder Aenderung gespeichert (default).<II>mak>II<addlist, setkey, selectlastmode, delkey, setdesc, getdesc, gettdesc, gettcmd, key_press, keys_set_bindings<II>var>II<keys_dmode, tasten_slist<II>list>II<tasten<II>version>II<keys.tf,v 1.8 2002/01/29 17:37:39 olm (Olli@mg.mud.de)<II>req>II<lists.tf<II>type>II<fileinfo<II>fileinfo>II<keys.tf<II><I>untroom_hide_mud_output>I<<II>info>II<Wenn gesetzt, wird die Ausgabe des Mud fuer den untersuche Befehl nicht mehr ausgegeben<II>type>II<cfg<II>fileinfo>II<untroom.tf<II><I>set_style>I<<II>info>II<Wenn gesetzt, wird vom TF die Herkunft des gerade angezeigten Details angezeigt (als Hervorhebung im Originaltext)<II>type>II<cfg<II>info>II<Setzt das Displayattribut der Herkunftsanzeige.<II>see>II<attributes, herkunftsanzeige, untroom.tf<II>syn>II</set_style attribut<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>do_highlight_untroom_actions>I<<II>info>II<Einschalten des Hervorhebens besonderer Worte (Aktionen) aus %highlight_untroom_actions im Ausgabetext<II>see>II<do_highlight_untroom_actions, untroom_highlight_action_attr<II>type>II<cfg<II>fileinfo>II<untroom.tf<II><I>untroom_highlight_action_attr>I<<II>info>II<Attribute fuer das Hervorheben besonderer Worte (Aktionen)<II>type>II<cfg<II>fileinfo>II<untroom.tf<II><I>highlight_untroom_actions>I<<II>see>II<highlight_untroom_actions, do_highlight_untroom_actions<II>info>II<Liste der Aktionsworte zur Hervorhebung im Ausgabetext<II>see>II<untroom_highlight_action_attr, do_highlight_untroom_actions<II>type>II<cfg<II>fileinfo>II<untroom.tf<II><I>default_details>I<<II>info>II<Enthaelt alle Details, die standardmaessig mit untersucht werden sollen, sie werden als Details der P_LONG des Raumes betrachtet<II>see>II<untroom<II>type>II<cfg<II>fileinfo>II<untroom.tf<II><I>save_room>I<<II>info>II<Speichert ob nach Beenden des Untersuchens, der aktuelle Raum gespeichert werden soll.<II>type>II<var<II>fileinfo>II<untroom.tf<II><I>untroom>I<<II>info>II<Mit diesem Befehl wird das Untersuchen eines Raumes (neu) gestartet. Die vorhandenen Listen werden resettet. Es beginnt mit 'schaue'.<II>syn>II</untroom<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>add_default_details>I<<II>info>II<fuegt die in der Liste %default_details enthaltenen Details denen der P_LONG des Raumes hinzu<II>cfg>II<default_details<II>list>II<default_details, detlist<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>todo>I<<II>info>II<Merkt sich Details in der Detailliste zum spaeteren untersuchen, praktisch wenn man mittendrin noch Details feststellt, die es lohnen untersucht zu werden<II>ex>II</todo Ast<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>todos>I<<II>info>II<Merkt sich Details in der Detailliste zum spaeteren untersuchen, praktisch wenn man mittendrin noch Details feststellt, die es lohnen untersucht zu werden, es koennen mehrere Details (jeweils ein Wort zusammen uebergeben werden)<II>ex>II</todo Ast Zweige Baum<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>unt2>I<<II>info>II<Details koennen damit ein zweites Mal untersucht werden, sie werden einfach aus der entsprechenden Liste geloescht.<II>list>II<done_delist<II>syn>II</unt2 detail<II>see>II<unt, untroom<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>unt>I<<II>info>II<Dieser Befehl untersucht das angegebene Detail und verarbeitet die Ausgaben des Muds entsprechend. Es werden alle Substantive herausgesucht und diese durch die entsprechenden Listen geschickt. Ausserdem wird das naechste Detail herausgesucht und angeboten. @{N}es wird @{B}unt detail im raum@{n} benutzt!<II>syn>II</unt detail<II>see>II<untroom, unt2<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>def_save_trig>I<<II>info>II<Trigger fuer Grabben des Mud Outputs<II>cfg>II<untroom_hide_mud_output<II>type>II<trig<II>fileinfo>II<untroom.tf<II><I>add_to_detail>I<<II>info>II<Fuegt die einzelnen Zeilen der Mudausgabe zu einem String zusammen, dabei werden Trennungsstriche am Zeilenende zusammengefuegt.<II>var>II<fulldetail, detail<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>find_words>I<<II>info>II<Sucht die Substantive aus dem String und speichert sie in den Listen. Wenn sie schon vorhanden waren, werden die alten geloescht.<II>list>II<akt_detlist, detlist<II>var>II<fulldetail<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>next_det>I<<II>info>II<Sucht das naechste Detail aus den Listen, veranlasst die Anzeige der Herkunft des Details und gib '/unt detail' zum Bestaetigen an das tf.@{N}Dabei wird das /unt um eine maximale Zeit verzoegert (einstellbar, Default ist eine Sekunde).<II>list>II<detlist<II>mak>II<do_show_origin<II>var>II<akt_det, last_parent,<II>see>II<unt, show_origin, set_delay<II>type>II<misc<II>fileinfo>II<untroom.tf<II><I>do_show_origin>I<<II>info>II<Zeigt die Herkunft des Details an. Dies ist auch ausschaltbar.<II>var>II<show_origin<II>version>II<1.03<II>changes>II<Fehler bei der Darstellung beseitigt.<II>mak>II<echo2<II>cfg>II<show_origin<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>delete_sub_details>I<<II>info>II<Damit werden alle Substantive, die in der zuletzt angezeigten Herkunftsanzeige auftauchen, als schon untersucht markiert. Das ist nuetzlich, wenn z.B. NPCs oder Spieler untersucht werden.@{N}Tip: Keybinding im Spielerfile machen.<II>see>II<herkunftsanzeige<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>save_most>I<<II>info>II<Wenn die Most-Liste geaendert wurde, wird bei /quit dieses Makro aufgerufen, mit dem sie sortiert und abgespeichert wird.<II>see>II<most, sort_most<II>list>II<most<II>version>II<1.01<II>changes>II<1.01 Fehler in /sortMost behoben, wenn die Anzahl keine Zahl ist..<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>sort_most>I<<II>info>II<Damit wird die Most-Liste sortiert. Die Eintraege haben einen Zaehler, wie haeufig sie in den Texten auftreten, und nach dieser Haeufigkeit werden sie sortiert.<II>see>II<most, save_most<II>list>II<most<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>delay>I<<II>info>II<Verzoegert eine Aktion die angegebene Zeit.<II>syn>II</delay zeit aktion<II>mak>II<time<II>var>II<permit<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>del_schaue>I<<II>info>II<Verzoegert und fuehrt das 'schaue' fuer den Raum aus. Vor der Raumbeschreibung wird durch /echo eine Leerzeile erzeugt.<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>del_unt>I<<II>info>II<Verzoegert und fuehrt das '/unt detail' fuer den Raum aus. Vor der Raumbeschreibung wird durch /echo eine Leerzeile erzeugt.<II>type>II<mak<II>fileinfo>II<untroom.tf<II><I>nichts_unt>I<<II>info>II<Loescht das aktuelle Detail und holt das naechste zur Bearbeitung. Dafuer sollte auch ein Keybinding in der Spielerdatei existieren.<II>see>II<delete_sub_details, nichts<II>type>II<misc<II>fileinfo>II<untroom.tf<II><I>reunt>I<<II>info>II<Loescht das aktuelle Detail. Dieser Befehl eignet sich zum Unterbrechen des Untersuchens. Mit /reunt kann das geloeschte Detail wieder geholt werden und mit dem Binding fuer /nichts_unt kann mit dem naechsten Detail fortgefahren werden.@{N}Dafuer sollte auch ein Keybinding in der Spielerdatei existieren.<II>see>II<delete_sub_details, nichts_unt, reunt,<II>type>II<misc<II>info>II<Damit wird das letzte Detail (z.B. nach /nichts) wieder hergeholt und als /unt detail angezeigt.@{N}Dafuer sollte auch ein Keybinding in der Spielerdatei existieren.<II>see>II<nichts, nichts_unt, delete_all_subdetails<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>show_origin>I<<II>info>II<Wechselt zwischen den zwei Zustaenden der Variablen 'show_origin', also der Herkunftsanzeige.@{N}Wuerde sich ggf. ein Keybinding im Spielerfile lohnen.<II>see>II<do_show_origin, herkunftsanzeige<II>var>II<show_origin<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>detail_idee>I<<II>info>II<Fuegt das letzte nicht vorhandene Detail in eine Liste ein, die dann nach dem Untersuchen des Raumes mit /send_idee abgeschickt wird.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II<send_idee, herkunftsanzeige<II>var>II<ideas<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>inputtypo>I<<II>info>II<Mit diesem Kommando wird ein Typo in der letzten Herkunftsanzeige gemeldet. Dazu wird der vorbereitete Text in die Kommandozeile geschrieben.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II<herkunftsanzeige<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>input_idee>I<<II>info>II<Mit diesem Kommando wird eine Idee fuer ein fehlendes Detail in der letzten Herkunftsanzeige gemeldet. Dazu wird der vorbereitete Text in die Kommandozeile geschrieben.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II<herkunftsanzeige<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>send_idee>I<<II>info>II<Schickt die Liste mit fehlenden Details ab. Immer dran denken, ich vergesse es immer.<II>see>II<herkunftsanzeige, detail_idee, show_idee<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>show_idee>I<<II>info>II<Zeigt die Liste mit den fehlenden Details an.<II>see>II<herkunftsanzeige, detail_idee, send_idee<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>herkunftsanzeige>I<<II>info>II<Die Herkunftsanzeige zeigt an, aus welcher Detailbeschreibung das aktuell zu untersuchende Detail stammt. Dabei wird das Detail entsprechend des angegebenen Stiles hervorgehoben.@{N}Die Herkunftsanzeige kann ein- und ausgeschaltet werden.<II>see>II<show_origin, set_style, typo, detail_idee<II>type>II<see<II>fileinfo>II<untroom.tf<II><I>add_most>I<<II>info>II<Fuegt das aktuelle Detail zu der Liste der zu uebergehenden Worte hinzu. Das naechste Detail wird dann zum Untersuchen angeboten.@{N}Es wuerde sich lohnen, ein Keybinding auf dieses Kommando zu machen.<II>see>II<reunt, typo, nichts, nichts_unt, most<II>list>II<most<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>set_delay>I<<II>info>II<Stellt die Zeit zwischen zwei Untersuche-Befehlen ein.<II>syn>II</set_delay zeit in sekunden (Default 1)<II>var>II<pdelay<II>type>II<comm<II>fileinfo>II<untroom.tf<II><I>untroom.tf>I<<II>info>II<Das ist die Datei mit dem Untersuche-Programm in tf. Bitte die Hilfe zu /untroom, /unt, und ggf. den restlichen Kommandos lesen.<II>changes>II<1.01 Fehler in /sort_most behoben.<II>changes>II<1.02 Neue Liste 'origin', in der die Originalform der Details gespeichert wird, da in den englischen Muds ein Grossbuchstaben am Anfang nicht das Original wiederherstellt.@{N}Ich hatte an zwei Stellen vergessen, 'schaue' durch %mud_look_command zu ersetzen, was hiermit geschehen ist.@{N}1.03 /do_show_origin wurde debuggt: Der Fehler, dass Teilworte markiert wurden, tritt jetzt nicht mehr auf.@{N}1.04 Beim Abschluss der Untersuchung werden die gesammelten Ideen zum Absenden vorgeschlagen.<II>req>II<tf4.0, loading.tf, lists.tf, util.tf, most.list.tf, help.tf customize.tf<II>tut>II<Das Untersuchen eines Raumes wird mit /untroom gestartet.@{N}/unt untersucht das angegebene Detail.@{N}/unt2 untersucht das angegebene Detail nochmal, auch wenn es schon einmal als untersucht markiert wurde.@{N}Wenn man beim Untersuchen ist, kann man: (meine Bindings)@{N}mit # (/nichts_unt) das aktuelle Detail verwerfen und zum naechsten gehen@{N}mit ^i (/detail_idee) das vorhergehende Detail der Ideenliste hinzufuegen@{N}/show_idee zeigt die bisher gesammelten Ideen@{N}/send_idee schickt sie ab@{N}mit ^a (/add_most) das aktuelle Detail zur Ignoriere-Liste hinzufuegen@{N}mit ^d (/delete_sub_details) koennen alle Details, die im gerade angezeigten Text vorkommen, als schon untersucht markiert werden!!@{N}mit /inputtypo kann ein typo fuer den aktuell angezeigten Text abgesetzt werden@{N}falls man die Zeile geloescht hat, mit /reunt das aktuelle Detail zurueckholen.@{N}Sonstiges:@{N}Das Attribut fuer das Einfaerben in der Herkunftsanzeige wird mit '/set_style attrib' gesetzt.@{N}Diese Version hat die Ignoriere-Liste (most) erweitert; in ihr steht jetzt auch, wie oft diese Details vorgekommen sind. So kann die Liste sortiert werden, so dass die haeufigsten Details vorn stehen und nicht so lange gesucht werden. Das Sortieren und _Abspeichern_ der Ignoriere-Liste erfolgt mit /save_most. Da man das meist vergisst, hab ich das /quit ueberschrieben ;)@{N}@{N}Weitere Features: am Zeilenende getrennte Worte werden erkannt, nur nicht in der Herkunft angezeigt.@{N}<II>misc>II<next_det, nichts_unt<II>see>II<herkunftsanzeige<II>comm>II<set_style, untroom, todo, todos, unt2, unt, delete_sub_details, reunt, show_origin, detail_idee, inputtypo, input_idee, send_idee, show_idee, add_most, set_delay<II>mak>II<add_default_details, add_to_detail, find_words, do_show_origin, save_most, sort_most, delay, del_schaue, del_unt<II>trig>II<def_save_trig<II>var>II<save_room<II>cfg>II<untroom_hide_mud_output, do_highlight_untroom_actions, untroom_highlight_action_attr, highlight_untroom_actions, default_details<II>version>II<untroom.tf,v 1.14 2002/03/27 01:44:36 mh14 (Mesirii@mg.mud.de)<II>req>II<!lists.tf<II>type>II<fileinfo<II>fileinfo>II<untroom.tf<II><I>status_colors>I<<II>info>II<Funktion, die in status_var_xxx vor der eigentlichen Variablen aufgefuehrt werden muss, und die die Statuszeile bei jedem Aufruf (aber max. 1x pro Sekunde) neu setzt und damit die Farben bzw. Attribute an die Werte aller Variablen anpassen kann.<II>ex>II</def status_color_a=/return (a<10)?"Cgreen":"Cred"@{N}/set status_field=a:10:$[status_color_a()]@{N}oder@{N}/set status_var_a=status_colors(a)@{N}Statuszeile@{N}/set status_field=a:10:$[(a<10)?"Cgreen":"Cred"]@{N}Basisstatuszeile, oder einmal /status_colors aufrufen@{N}/set status_fields=a:10<II>type>II<func<II>fileinfo>II<status.tf<II><I>config_status>I<<II>info>II<Einfache Statuszeilendefinition, die fast direkt so angegeben wird, wie sie spaeter aussehen soll. Dabei wird fast alles direkt uebernommen, nur die angegebenen Variablen werden entweder aus vorgefertigten, mitgelieferten Modulen entnommen oder (vorher) on the fly erzeugt; wenn beides nicht moeglich ist, wird die Variable direkt uebernommen. Die Aenderungen sind sofort sichtbar.<II>syn>II</config_status Statuszeilendefinition<II>ex>II</config_status __LP:{lp}_MP:{p_mp}__abc__!!!__ABC__{a}_{@world}_{insert:1}@{N}* Alle __ werden direkt umgesetzt, auch die Strings, nur die Variablen in {} erhalten eine besondere Behandlung.@{N}* Wenn ein Makro (Modul) namens sl_%{varname} vorhanden ist, wird dieses ausgefuehrt, um z.B. Attribute, Breiten, Trigger, Standardwerte zu definieren, und sein Ergebnis in die Statuszeile integriert.@{N}* Wenn eine Variable status_line_%{varname} vorhanden ist, wird angenommen, dass die Variablen bereits per /set_status_var_(num|string) definiert wurde und die status_line_%{varname} wird in die Statuszeile integriert.@{N}* Ansonsten wird die Variable direkt unter ihrem Namen in die Statuszeile eingetragen, ohne besondere Formatierung und Laengenangaben.<II>see>II<set_status_var_num, set_status_var_string, status_colors<II>type>II<comm<II>fileinfo>II<status.tf<II><I>config_status_static>I<<II>info>II<Parst und verarbeitet die statischen Elemente der Statuszeile wie _ und feste Strings.<II>syn>II</config_status_static String mit nur statischen Elementen<II>ex>II</config_status_static __MP:___LP:__!!!____abc__@{N}return: :2 "MP:" :3 "LP:" :2 "!!!" :4 "abc" :2<II>see>II<config_status<II>return>II<verabeiteter String<II>type>II<mak<II>fileinfo>II<status.tf<II><I>set_status_var_num>I<<II>info>II<Definiert eine numerische Variable fuer die Statuszeile sofort (on the fly). Die Attribute werden fuer eine Vergleichsliste angegeben (siehe /attr_ordered). Wenn statt des Defaultwertes der Variablenname noch einmal angegeben wird, wird diese Variable nur per Selbstzuweisung initialisiert (d.h. bleibt unveraendert, wenn schon existent).<II>syn>II</set_status_var_num varname defaultwert breite vglwert1 attr1 vglwert2 attr2 default_attr<II>ex>II</set_status_var_num lp 220 3 80 Cred 160 Cyellow Cgreen<II>see>II<attr_ordered<II>type>II<mak<II>fileinfo>II<status.tf<II><I>infodefiniert eine variable fuer die statuszeile sofort (on the fly). die informationen zur darstellung werden aus den konfigurationsvariablen fuer farbe und text geholt (color_sl_varname*, text_sl_varname*)@{n}wenn statt des defaultwerts der variablenname noch einmal angegeben wird, wird die variable per selbstzuweisung aktualisiert>I<<II>type>II<misc<II>fileinfo>II<status.tf<II><I>set_status_var_string>I<<II>syn>II</set_status_var_string varname defaultwert|varname breite text1 text2 text3 ...<II>ex>II</set_status_var_string p_align p_align 3 heilig gut nett neutral frech boese satanisch<II>type>II<mak<II>fileinfo>II<status.tf<II><I>set_status_var_flag>I<<II>info>II<Methoden um Statuszeilenvariablen die auf Flags basieren, on the Fly zu definieren, dabei werden wenn vorhanden und gewuenscht Konfigurationsvariablen fuer Attribute (COLOR_SL_*) und Texte (TEXT_SL_*) genutzt werden (ggf. auch fuer ausgeschalteten Status (COLOR_SL_*_OFF,TEXT_SL_*_OFF))@{N}Wenn Farb- und Textinformationen angegeben werden, werden mit diesen Werten die entsprechenden Konfigurationsvariablen gesetzt (s.o.)<II>syn>II</set_status_var_flag varname default breite [Text_an Attr_an [Text_aus Attr_aus]]<II>ex>II</set_status_var_flag p_frog 0 1@{N}/set_status_var_flag p_blind 0 1 B Cbgmangenta@{N}/set_status_var_flag p_block 0 1 + Cyellow - n<II>type>II<mak<II>fileinfo>II<status.tf<II><I>dep_var>I<<II>info>II<liefert den Konfigurationsvariablennamen fuer die angegebene Variable zurueck, es gibt Konfigurationen fuer Farbe und Text. Ein uebergebener Suffix wird mit angehaengt<II>syn>II</status_get_config_name varname [c|t|beliebig] beliebiger suffix<II>ex>II</status_get_config_name p_frog c@{N}/status_get_config_name p_lp c 1@{N}/status_get_config_name p_block t OFF@{N}/addh status_get_config_name mak<II>info>II<Erzeugt eine Liste abhaengiger Variablen von der angegebenen Variablen X, diese werden beim Setzen dieser Variablen X per /dset mit aktualisiert (per Selbstzuweisung, so dass sie z.B. in der Statuszeile aktualisiert werden).@{N}Mit nur einem Parameter werden die abhaengigen Variablen angezeigt<II>see>II</undep_var, /dset<II>syn>II</dep_var varname [depending_var]<II>ex>II</dep_var a b@{N}/dep_var a (Zeigt Liste an)<II>type>II<mak<II>fileinfo>II<status.tf<II><I>undep_var>I<<II>info>II<Loescht Variablen aus der Liste der abhaengigen Variablen der zuerst angegebenen Variablen<II>syn>II</undep_var varname depending_var<II>see>II</dep_var, /dset<II>ex>II</undep_var a b<II>type>II<mak<II>fileinfo>II<status.tf<II><I>dset>I<<II>info>II<Setzt die angegebene Variable auf den Wert, arbeitet genau wie /set nur dass abhaengige Variablen aktualisiert werden (d.h. per Selbstzuweisung /test a:=a) so dass die Statuszeile sie aktualisiert anzeigt. Wichtig ist das, wenn die Attribute (status_attr_varname) oder Anzeige (status_var|func_varname sich aus aus der hier gesetzten Variablen ergeben. Das passiert aber nur, wenn sich der Wert wirklich geaendert hat!<II>syn>II</dset varname[[=| ]value]<II>ex>II</dset a=10@{N}/dset a (Zeigt wie /set an)<II>see>II<dep_var, undep_var<II>type>II<mak<II>fileinfo>II<status.tf<II><I>self_update>I<<II>info>II<Aktualisiert die angegebenen Variablen durch eine Selbstzuweisung (/test a:=a), damit sie eine Aktualisierung der  Statuszeile hervorrufen<II>see>II</dep_var,/dset,/undep_var<II>syn>II</self_update var1 var2 ...<II>ex>II</self_update a b c<II>type>II<mak<II>fileinfo>II<status.tf<II><I>format_number>I<<II>info>II<formatiert eine grosse Zahl mittels angehaegter k bzw. M und den restlichen vorangehenden Stellen<II>ex>II</format_number 1000 -> 1k; /format_number 1000000 -> 1M<II>type>II<mak<II>fileinfo>II<status.tf<II><I>attr_ordered>I<<II>info>II<Erzeugt einen Ausdruck, der den ersten Parameter (Varname) mit den jeweils folgenden vergleicht und die angegebenen Attribute zurueckgibt.<II>syn>II</attr_ordered varname vglwert1 attr1 vglwert2 attr2 .. default_attr<II>ex>II</attr_ordered lp 80 Cred 160 Cyellow Cgreen<II>type>II<mak<II>fileinfo>II<status.tf<II><I>attr_ordered_cmp>I<<II>info>II<Liefert einen Vergleichsausdruck fr die Variable (%1), mit dem Operator (%2). Dabei kann angegeben werden, ob die Vergleichswerte Strings sind (%3 ist " oder ') und ob die Ergebnisswerte Strings oder Variablennamen sind (%4 ist ' oder " bei String), in %5+2*i stehen die Vergleichswerte, und in %6+2*i die Ergebniswerte<II>syn>II</attr_ordered_cmp varname operator ['".] ['".] compare1 result1 compare2 result2 ... [result_default]<II>ex>II</attr_ordered_cmp hp < . . maxhp/3 COLOR_HP_33 maxhp*2/3 COLOR_HP_66 COLOR_HP<II>type>II<mak<II>fileinfo>II<status.tf<II><I>status_get_quote>I<<II>info>II<liefert wenn ein TF-Quote Zeichen uebergeben wurde dieses zurueck, sonst einen Leerstring<II>type>II<mak<II>fileinfo>II<status.tf<II><I>status_config_set_attr>I<<II>info>II<Gibt einen TF-Ausdruck zurueck, der die uebergebene Variable mit dem Operator mit den Vergleichswerten vergleicht und die korrekten Statuskonfigurationsvariablen als Ergebniswerte einsetzt (abhaengig vom ersten Parameter), ausserdem werden die Konfigurationsvariablen gleich auf die uebergebenen Werte gesetzt.@{N}Die Konfigurationsvariablen werden einfach aufsteigend nummeriert.<II>syn>II</status_config_set_attr [c|t] varname operator ['".] vergleichswert1 Configwert1 vergleichswert2 Configwert2 ... [DefaultConfigWert]<II>ex>II</status_config_set_attr c p_lp < . 60 Cred 120 Cyellow Cgreen@{N}/status_config_set_attr t p_align =~ ' gut + neutral * boese -<II>see>II<status_config_attr<II>type>II<mak<II>fileinfo>II<status.tf<II><I>status_config_attr>I<<II>info>II<Gibt einen TF-Ausdruck zurueck, der die uebergebene Variable mit dem Operator mit den Vergleichswerten vergleicht und die korrekten Statuskonfigurationsvariablen als Ergebniswerte einsetzt (abhaengig vom ersten Parameter). Die Konfigurationsvariablen werden einfach aufsteigend nummeriert.<II>syn>II</status_config_attr [c|t] varname operator ['".] vergleichswert1 vergleichswert2<II>ex>II</status_config_attr c p_lp < . 60 120@{N}/status_config_attr t p_align =~ ' gut neutral boese<II>see>II<status_config_attr<II>type>II<mak<II>fileinfo>II<status.tf<II><I>status.tf>I<<II>misc>II<infodefiniert eine variable fuer die statuszeile sofort (on the fly). die informationen zur darstellung werden aus den konfigurationsvariablen fuer farbe und text geholt (color_sl_varname*, text_sl_varname*)@{n}wenn statt des defaultwerts der variablenname noch einmal angegeben wird, wird die variable per selbstzuweisung aktualisiert<II>comm>II<config_status<II>mak>II<config_status_static, set_status_var_num, set_status_var_string, set_status_var_flag, dep_var, undep_var, dset, self_update, format_number, attr_ordered, attr_ordered_cmp, status_get_quote, status_config_set_attr, status_config_attr<II>func>II<status_colors<II>version>II<status.tf,v 1.19 2002/03/27 01:21:13 mh14 (Mesirii@mg.mud.de)<II>req>II<<II>info>II<Statuszeile, die ihre Attribute selbst aendern kann<II>type>II<fileinfo<II>fileinfo>II<status.tf<II><I>wo_show_bug>I<<II>info>II<Schaltet die Ausgabe des gegrabbten Textes fuer den Raum bei einem fehlerhaften /wo ein bzw. aus<II>type>II<cfg<II>fileinfo>II<way.tf<II><I>alitype>I<<II>info>II<Variable, die bestimmt, wie die Knoten dargestellt werden sollen<II>ex>II<wert   Beispiel@{N}short  mesi@{N}long   mesi Haus Mesirii (Ebene)@{N}geb    mesi (Ebene)@{N}info   mesi Haus Mesirii<II>type>II<var<II>fileinfo>II<way.tf<II><I>movement_marker>I<<II>info>II<Trennzeichen fuer das /walk == ?speedwalk<II>see>II<walk<II>ex>II<default: ,<II>type>II<var<II>fileinfo>II<way.tf<II><I>mapper_port>I<<II>info>II<Port auf dem der Mapper laeuft (default 2000)<II>type>II<var<II>fileinfo>II<way.tf<II><I>~addway>I<<II>info>II<Fuegt einen !kompletten Weg zur Liste ?ways hinzu.<II>list>II<ways<II>see>II<~getway, ways<II>type>II<mak<II>fileinfo>II<way.tf<II><I>~getway>I<<II>info>II<Liefert einen kompletten Weg aus der Liste ?ways zurueck.<II>list>II<ways<II>see>II<~addway, ways<II>type>II<mak<II>fileinfo>II<way.tf<II><I>ways>I<<II>info>II<Die Liste 'ways' enthaelt alle Wege in kompletter Form:@{N}Anfang: Subliste aller wegfuehrenden Wege, naechster Anfang ...@{N}Subliste: Ziel Dimension([n]ormal|[p]arawelt|[b]eides|[0-9].Parawelt)@{N}Erlaubnis(siehe dort), Laenge des Wegs Weg, naechstes Ziel ...@{N}Aus dieser Liste werden zwei Indizes erzeugt: Der 'fromidx', der eine verkuerzte Form von Ways darstellt, d.h. ohne die eigentlichen Wege, und der 'toidx', der die nach Zielen gruppierte Liste enthaelt.<II>see>II<knoten, dimensionen, portale, wege<II>list>II<fromidx, toidx<II>type>II<see<II>fileinfo>II<way.tf<II><I>knoten>I<<II>info>II<Die Knoten des Wegesystems halten dieses zusammen. Zwischen ihnen verlaufen die Wege. Die Knoten werden als Raeume erkannt, sie sind Anfangs-, Zwischen- und Zielpunkte jedes berechneten Weges. Die Knoten werden in allen Wegelisten abgespeichert.@{N}Fuer die Knoten gelten bestimmte Namenskonventionen:@{N}In den Knotennamen sollten nur Buchstaben, Zahlen und Unterstriche stehen.@{N}Kneipe: Kname, Laden: Lname, Portale tname, Seherhaeuser: ein paar Buchstaben des Namens des Sehers (kleingeschrieben)@{N}Es gibt ein paar reservierte Namen: tport, laden, kneipe.@{N}Bitte haltet Euch an die Konventionen, sie sind sehr wichtig.@{N}Fuer jeden Knoten kann mit /setali ein Aliasname vergeben werden, der dann ganz normal genutzt werden kann.@{N}Jeder der Knoten kann mittels /wo als Raum im Mud erkannt werden. Mit /lp kann man auch Knoten per Hand setzen, das sollte aber nicht noetig sein. Die Anzeigevariable fuer die Knoten lautet %showpoint. Diese zeigt auch die ggf. vorhandenen Aliase korrekt an.<II>comm>II<shownode, setali, appendnode, addnode, delnode, wo<II>list>II<lastpoints, nodealias, ways, toidx, fromidx, often, often2, tanken /addh see wege, tanken, spezialknoten, portale, knotenaliase<II>var>II<showpoint, lastpoint<II>type>II<see<II>fileinfo>II<way.tf<II><I>wege>I<<II>info>II<Die Wege des Systems werden in einer grossen Liste (?ways) gespeichert. Sie werden durch Anfangs- und Endknoten und gewisse Einschraenkungen definiert. Die Eingabe der Wege kann direkt im Mud erfolgen. Es ist also nicht notwendig, die Listen von Hand zu bearbeiten (und auch nicht zu empfehlen!!!). Die Eingabe der Wege erfolgt einfach durch das einmalige Ablaufen des Weges. Wenn Sonderbewegungsbefehle entsprechend beruecksichtigt wurden, sind danach beide Wege (Hin- und Rueckweg) verfuegbar. Das Abspeichern eines Weges erfolgt mit /end (siehe dort).@{N}Es gibt mehere Kommandos zum Verwalten der Wege, die alle dieselbe Syntax haben:@{N}/kommando anfangsknoten|* endknoten|* @{B}(* * ist unzulaessig)@{n}@{N}ACHTUNG: Die Editierkommandos speichern die Aenderungen sofort ab!<II>comm>II<showway, editway, delway<II>list>II<disabled, often, often2<II>type>II<see<II>fileinfo>II<way.tf<II><I>lp2>I<<II>info>II<Setzt den aktuellen Knoten auf den uebergebenen Parameter. Der Inhalt der Variablen %cond_go wird geloescht. Wenn der Mapper aktiv ist (%mapper==1), wird ein 'go knotename' an den Mapper gesandt.<II>var>II<lastpoint, cond_go, showpoint<II>see>II</cond_go, mapper<II>type>II<mak<II>fileinfo>II<way.tf<II><I>lp>I<<II>info>II<Setzt den aktuellen Knoten. Dabei wird nicht geprueft, ob dieser Knoten schon existiert. Das kann genutzt werden, wenn /wo versagt, oder wenn man von diesem neuen Knoten aus eine Weg erstellen will.(Dann aber nach dem /lp /appendnode aufrufen.)@{N}Der Puffer fuer die Wegaufzeichnung wird geloescht!!<II>var>II<showpoint, lastpoint<II>see>II<wo, knoten<II>type>II<comm<II>fileinfo>II<way.tf<II><I>wayindex>I<<II>info>II<Nach manuellen Arbeiten an der Liste ways MUSS /wayindex aufgerufen werden, damit die Indexlisten neu erstellt werden!<II>list>II<fromidx, toidx<II>see>II<wege, ways<II>var>II<temp_list, temp_list2<II>mak>II<sort_idx_list, savelist, alle moeglichen Listenbefehle<II>type>II<comm<II>fileinfo>II<way.tf<II><I>sort_idx_list>I<<II>info>II<Sortiert eine Wegknotensubliste nach der Laenge der Teilwege.<II>syn>II</sort_idx_list subliste<II>var>II<stemp_list<II>type>II<mak<II>fileinfo>II<way.tf<II><I>initfind>I<<II>info>II<Initialisiert die Listen fuer das Wegberechnen.<II>list>II<froml_w, tol_w, froml_k, tol_k<II>var>II<nofrom, noto, fromlen, tolen, frommaxlen, tomaxlen<II>type>II<mak<II>fileinfo>II<way.tf<II><I>find5>I<<II>info>II<Enthaelt die Hauptschleife fuer das Wegesuchsystem, d.h. von den zwei Endpunkten aus werden sternfoermig die kuerzesten Wege gesucht, und bei Ueberschneidungen der beiden Netze wird der gefundene Gesamtweg benutzt.<II>var>II<portals, gmaxlen, break,<II>list>II<l_k, temp_fromidx, temp_toidx<II>mak>II<initfind, getshortestway, find6<II>type>II<mak<II>fileinfo>II<way.tf<II><I>find6>I<<II>info>II<Fuehrt die Wegesuche fuer jeden einzelnen Knoten der Start- und Zielnetze aus.<II>var>II<(~ bedeutet jeweils from und to) ~len, ~node, ~way, ~maxlen, len, node, way, maxlen<II>list>II<~ bedeutet jeweils from und to l_k, temp_~idx, temp_list<II>mak>II<iskey, disabled, allowed, testcon<II>type>II<mak<II>fileinfo>II<way.tf<II><I>testcon>I<<II>info>II<Testet, ob sich Hinweg und Rueckweg schon treffen.<II>var>II<min_steps, gmaxlen, min_way, (~ bedeutet jeweils from bzw. to) ~slen, ~maxlen<II>list>II<~l_k<II>mak>II<killlongerways<II>type>II<mak<II>fileinfo>II<way.tf<II><I>killlongerways>I<<II>info>II<Loescht die Wege, die laenger als die angegebene Variable (from|to)maxlen sind aus der Liste (from|to)temp_list.<II>var>II<maxlen, (~ = from|to) ~maxlen, ~temp_list<II>syn>II<killlongerways (from|to)<II>type>II<mak<II>fileinfo>II<way.tf<II><I>getshortestway>I<<II>info>II<Liefert den kuerzesten Weg aus der Liste (from|to)l_w.<II>var>II<len, maxlen, (~ = from|to) ~templ_w, ~len, ~maxlen, ~l_w<II>return>II<value=kuerzester Weg oder -1, wenn keine Wege mehr vorhanden sind oder sie eine Laenge >1000 haben.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>count_steps>I<<II>info>II<Initialisiert die Listen fuer das Wegberechnen.<II>list>II<froml_w, tol_w, froml_k, tol_k<II>var>II<nofrom, noto, fromlen, tolen, frommaxlen, tomaxlen<II>type>II<mak<II>info>II<Enthaelt die Hauptschleife fuer das Wegesuchsystem, d.h. von den zwei Endpunkten aus werden sternfoermig die kuerzesten Wege gesucht, und bei Ueberschneidungen der beiden Netze wird der gefundene Gesamtweg benutzt.<II>var>II<portals, gmaxlen, break,<II>list>II<l_k, temp_fromidx, temp_toidx<II>mak>II<initfind, getshortestway, find6<II>type>II<mak<II>info>II<Fuehrt die Wegesuche fuer jeden einzelnen Knoten der Start- und Zielnetze aus.<II>var>II<(~ bedeutet jeweils from und to) ~len, ~node, ~way, ~maxlen, len, node, way, maxlen<II>list>II<~ bedeutet jeweils from und to l_k, temp_~idx, temp_list<II>mak>II<iskey, disabled, allowed, testcon<II>type>II<mak<II>info>II<Testet, ob sich Hinweg und Rueckweg schon treffen.<II>var>II<min_steps, gmaxlen, min_way, (~ bedeutet jeweils from bzw. to) ~slen, ~maxlen<II>list>II<~l_k<II>mak>II<killlongerways<II>type>II<mak<II>info>II<Loescht die Wege, die laenger als die angegebene Variable (from|to)maxlen sind aus der Liste (from|to)temp_list.<II>var>II<maxlen, (~ = from|to) ~maxlen, ~temp_list<II>syn>II<killlongerways (from|to)<II>type>II<mak<II>info>II<Liefert den kuerzesten Weg aus der Liste (from|to)l_w.<II>var>II<len, maxlen, (~ = from|to) ~templ_w, ~len, ~maxlen, ~l_w<II>return>II<value=kuerzester Weg oder -1, wenn keine Wege mehr vorhanden sind oder sie eine Laenge >1000 haben.<II>type>II<mak<II>info>II<Berechnet die Laenge des Wegs ueber das Zaehlen von %;<II>syn>II<$(/count_steps Weg)<II>return>II<die Laenge ueber /echo, also $()<II>type>II<mak<II>fileinfo>II<way.tf<II><I>askway>I<<II>info>II<Damit kann man den Zustand 'askway' umschalten. Wenn askway eingeschaltet ist, wird der Weg berechnet und angezeigt. Dann wird auf eine Eingabe gewartet. Wenn diese (n)ein ist, wird der Weg nicht gegangen, ansonsten (Return) wird der Weg gegangen.<II>see>II<go<II>var>II<askway<II>type>II<comm<II>fileinfo>II<way.tf<II><I>gof>I<<II>info>II<Damit es nicht immer so muehselig ist, erst /wo und dann /go zu benutzen, habe ich den Befehl /gof hinzugefuegt, dessen erster Parameter der Ausgangsknoten ist.<II>ex>II</gof start ziel<II>see>II<go, wo<II>type>II<comm<II>fileinfo>II<way.tf<II><I>ago>I<<II>info>II<ago fuehrt alles was nach dem Zielknoten als Parameter uebergeben wird am Ziel als Befehle aus. Die Parameter koennen TF oder Mudbefehle sein (Trennung durch %;)<II>ex>II</ago kneipe kaufe bier<II>type>II<comm<II>fileinfo>II<way.tf<II><I>after_go>I<<II>info>II<die Variable %after_go kann beliebige Kommandos (Mud oder tf) enthalten, die nach erfolgreichem Ablaufen eines Weges ausgefuehrt werden. Der Trenner fuer tf sollte aber escaped werden.<II>ex>II</set after_go /echo Jetzt bin ich fertig\%;tanze\%;@{N}/go ziel@{N}Jetzt bin ich fertig@{N}Du tanzt.<II>see>II<go<II>type>II<var<II>fileinfo>II<way.tf<II><I>wgo>I<<II>info>II<Testet ob er den aktuellen Raum kennt. Wenn ja, wird der Weg gegangen (via /_go), und wenn nicht, gibt es eine Fehlermeldung.<II>see>II<go, wo<II>type>II<comm<II>fileinfo>II<way.tf<II><I>bgo>I<<II>info>II<Geht zum Knoten Startknoten des letzten /go zurueck<II>type>II<comm<II>fileinfo>II<way.tf<II><I>go>I<<II>info>II<Ist der wichtigste Befehl des Wegeprogramms.@{N}Syntax: /go [knoten1 knoten2 ...] endknoten@{N}Es wird ein Weg ueber die angegebenen Knoten zum Endknoten berechnet. Der Weg wird angezeigt und dann geht es los. ;)@{N}Da der Weg, der vom letzten bekannten Knoten aus gegangen wurde, mitgeloggt wurde, wird zuerst zu dem letzten bekannten Knoten gegangen, danach wird der berechnete Weg zum Zielknoten gegangen.@{N}Dabei gibt es folgende Besonderheiten: Fehler treten auf, wenn auf dem Weg zum letzten bekannten Knoten Wegebefehle auftreten, die keine Richtungs- befehle sind oder wenn der Rueckweg zum Knoten anders verlaeuft als der Hinweg.@{N}Fehler (Zyklus) werden gemeldet, wenn der Startknoten im Laufe des (erzwungenen) Weges wieder passiert wird.@{N}Waehrend des Weges kann allerlei passieren:@{N}Fall kein bekannter Startpunkt vorhanden ist, wird das gemeldet.@{N}Wenn ein Hindernis im Weg steht und das im Weg vorgesehen ist, wird man gefragt, ob man den Weg temporaer sperren will. Wenn ja, wird dies getan, und man kann mit /continue oder /c zum letzten Knotenpunkt zuruecklaufen Wenn nein, muss man das Hindernis beseitigen und kann dann mit /continue weiterlaufen bis zum Ziel.@{N}Wenn ein NPC vorgesehen ist, den man sowieso weghaut, gibt es die erste Variante nicht. Man bekommt aber eine schoene Meldung ;).@{N}Ausserdem koennen im Weg beliebige Makros enthalten sein, die dann alles moegliche machen. Zu diesen Sachen steht viel mehr unter Wegeingabe.@{N}Schon gegangene Wege werden in einer Liste temporaer zwischengespeichert, damit es beim zweiten Mal schneller geht. Wenn man einen Weg dauerhaft speichern will, so sollte man /ao benutzen.<II>see>II</gof, %after_go<II>changes>II<1.04 Fehlermeldung, wenn Teilknoten des Weges keine Ausgaenge hat, andere Fehlermeldungen praezisiert.@{N}1.05 der Inhalt der Variablen %after_go wird nach komplettem Ablaufen des Weges ausgefuehrt.<II>type>II<comm<II>fileinfo>II<way.tf<II><I>noport>I<<II>info>II<Schaltet die Portale aus. Loescht die Liste zwischengespeicherter Wege.<II>see>II<portale, dimensionen, para, nopara, port<II>var>II<portals<II>type>II<comm<II>fileinfo>II<way.tf<II><I>port>I<<II>info>II<Schaltet die Portale ein. Loescht die Liste zwischengespeicherter Wege.<II>see>II<portale, dimensionen, para, nopara, noport<II>var>II<portals<II>type>II<comm<II>fileinfo>II<way.tf<II><I>portale>I<<II>info>II<Da die Portale in einem Wegesystem eine grosse Zeitersparnis bringen, werden sie auch extra behandelt. Es gibt einen Befehl zum Ein- und Ausschalten der Portale.@{N}Ausserdem gibt es einen Spezialknoten namens 'tport' (bzw. %portal_node), der das naechstgelegene Portal bezeichnet, und von dem aus nur die Portale funktionieren.<II>comm>II<port, noport<II>var>II<portals<II>see>II<Spezialknoten, Wege<II>type>II<see<II>fileinfo>II<way.tf<II><I>dimensionen>I<<II>info>II<Da es neben der Normalwelt auch noch die Parawelt gibt und einige Weg dort nicht und andere nur dort funktionieren, ist die Einschraenkung Dimension mit in das Wegesystem integriert worden. @{N}Gueltige Werte dafuer sind (b)eide (n)ormal (p)arawelt, ([0-9]).Parawelt@{N}Bei der Wegeingabe kann so ein Weg entsprechend gekennzeichnet werden und diese Wege werden dann auch entsprechend beruecksichtigt.<II>var>II<dimension<II>see>II<para, nopara, ao, ways, wegeingabe, editway<II>type>II<see<II>fileinfo>II<way.tf<II><I>wpara>I<<II>info>II<Schaltet die aktuelle Dimension auf Parawelt um.<II>see>II<dimensionen, nopara, ways, editway, portale<II>var>II<dimension<II>type>II<comm<II>fileinfo>II<way.tf<II><I>nopara>I<<II>info>II<Schaltet die aktuelle Dimension auf Normalwelt um.<II>see>II<dimensionen, para, ways, editway, portale<II>var>II<dimension<II>type>II<comm<II>fileinfo>II<way.tf<II><I>testway>I<<II>info>II<Fuehrt die Berechnung genauso wie /go aus und zeigt den Ergebnisweg komplett an. Der Weg wird nicht ausgefuehrt, aber trotzdem in den Cache geschrieben, so dass bei einem nachfolgenden /go sofort losgelaufen wird.<II>see>II<go<II>ex>II</testway gilde<II>syn>II</testway zielknoten<II>type>II<comm<II>fileinfo>II<way.tf<II><I>go_way>I<<II>info>II<Erstellt aus der Abfolge der Knoten den eigentlichen Weg, testet ggf. ueber 'askway', ob man den Weg gehen will, geht zum letzten bekannten Knotenpunkt und startet von dort aus das Ablaufen des Weges. Vorher wird noch der Ultrakurzmodus  mittels ?mud_shortest_output eingeschaltet und vor dem letzten Befehl im Weg der Kurzmodus (?mud_short_output) eingeschaltet.<II>var>II<askway, min_way, real_way, temp_way, min_steps, fulldetail, verify<II>mak>II<go_way3, gobk<II>type>II<mak<II>fileinfo>II<way.tf<II><I>continue>I<<II>info>II<Nach einer Unterbrechung fuehrt /continue oder kurz /c den Weg entweder weiter oder geht zum letzten Knoten zurueck. Es wird vorher wieder mit 'mud_shortest_output' in den Ultrakurzmodus geschaltet.<II>see>II<wegeingabe<II>type>II<comm<II>fileinfo>II<way.tf<II><I>cont_way>I<<II>info>II<Geht den unterbrochenen Weg weiter. MUSS von eigenen Makros ausgefuehrt werden, nachdem sie ihre Funktion erfuellt haben.<II>mak>II<go_way3<II>var>II<go_way3_param<II>see>II<continue, wegeingabe<II>type>II<mak<II>fileinfo>II<way.tf<II><I>klp>I<<II>info>II<Loescht die Prompts der letzten Befehle an das Mud, so dass ein aktueller Einlesetrigger, der die Ausgaben des Muds liest, nur noch die des letzten Befehls bekommt (ueber ?mud_recognize_command).<II>see>II<wegeingabe, mud_recognize_command<II>var>II<mud_recognize_command<II>syn>II</klp naechstes Makro mit Parametern<II>type>II<mak<II>fileinfo>II<way.tf<II><I>wegmakros>I<<II>info>II<In den Wegen koennen ja beliebige Makros enthalten sein. Ein paar nuetzliche sind schon vorhanden.<II>see>II<lwo, npc, von, voff, wait, tri, utri, stop, continue, cw, cond_stop, cond_go, no_cond_go, break_tri, do_tri<II>type>II<see<II>fileinfo>II<way.tf<II><I>lwo>I<<II>info>II<Wartet, bis der richtige Raum errreicht ist, und macht dann /wo.<II>see>II<wegeingabe<II>type>II<mak<II>fileinfo>II<way.tf<II><I>npc>I<<II>info>II<Testet, ob ein NPC im Weg steht. Wenn ja, haelt es an. Mit /continue geht es dann weiter. Da es 'verify' einschaltet, muss nach dem kritischen Befehl das verify mit /voff wieder ausgeschaltet werden.<II>see>II<wegeingabe, von, voff<II>var>II<verify<II>mak>II<klp<II>type>II<mak<II>fileinfo>II<way.tf<II><I>von>I<<II>info>II<Schaltet 'verify' ein, d.h. bis /voff kommt wird, jeder Befehl auf Erfolg getestet. Wenn einer nicht erfolgreich ist, wird das mit der entsprechenden Fehlermeldung angezeigt. Mit dem Parameter 2 reagiert es so wie /npc. Nach dem kritischem Abschnitt muss verify mit /voff wieder ausgeschaltet werden.<II>see>II<wegeingabe, von, voff<II>mak>II<klp, cont_way<II>var>II<verify<II>syn>II</von [2]<II>ex>II<fuer einen Weg: n%;/von%;zu testender Schritt%;/voff%;s%;<II>type>II<mak<II>fileinfo>II<way.tf<II><I>voff>I<<II>info>II<Schaltet 'verify' aus. Danach werden alle Kommandos ohne Ueberpruefung ausgefuehrt.<II>see>II<wegeingabe, von<II>var>II<verify<II>mak>II<cont_way<II>type>II<mak<II>fileinfo>II<way.tf<II><I>cw>I<<II>info>II<Fuehrt seinen Parameter aus und setzt dann den Weg fort.<II>syn>II</cw Befehl<II>mak>II<cont_way<II>type>II<mak<II>fileinfo>II<way.tf<II><I>wait>I<<II>info>II<Wartet die angegebene Zahl Sekunden, bis der Weg weiter ausgefuehrt wird, und fuehrt ggf. das angegebenen Kommando aus. /wait kann benutzt werden, um im Zusammenhang mit /cond_go vor jedem Wegschritt eine Pause einzulegen (/cond_go /wait sekunden).<II>syn>II</wait sekunden [kommando]<II>mak>II<cont_way<II>see>II<cond_go, no_cond_go<II>type>II<mak<II>fileinfo>II<way.tf<II><I>cond_go>I<<II>info>II<Wenn innerhalb eines Weges angewandt, wird das Kommando gesetzt, das vor jedem Mud-Wegbefehl ausgefuehrt wird. Es kann z.B. zum Ueberpruefen komplexer Bedingungen in einem Gebiet genutzt werden, oder mit /wait zum Setzen einer Pause vor jedem Wegebefehl. Mit /no_cond_go wird dieser Modus wieder aufgehoben. Fuer die Kommandos, die mit /cond_go gesetzt werden, gelten folgende Bedingungen:@{N}* Der uebergebene Wegebefehl muss im Erfolgsfall ausgefuehrt werden.@{N}* Das Makro muss im Erfolgsfall mit /cont_way beendet werden, damit der Weg fortgesetzt werden kann.@{N}* Bei Komplettabbruch des Weges muss die Variable ?go auf 0 gesetzt werden.<II>ex>II</def check = /echo naechster Befehl %*%;/cw%; /cond_go /check@{N}'/cond_go /wait 4' wartet vor jedem Wegebefehl 4 Sekunden<II>var>II<cond_go<II>see>II<wait, no_cond_go<II>type>II<mak<II>fileinfo>II<way.tf<II><I>no_cond_go>I<<II>info>II<Setzt den mit /cond_go gesetzten Befehl zurueck.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>stop>I<<II>info>II<Haelt den Weg an. Er kann dann mit /continue fortgesetzt werden. Es wird der Kurzmodus (?mud_short_output) eingestellt und eine Meldung ausgegeben.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>cond_stop>I<<II>info>II<Wenn die Bedingung erfuellt ist, wird an der Stelle der Weg angehalten und kann dann mit /continue fortgesetzt werden.<II>syn>II</cond_stop bedingung<II>ex>II</cond_stop 1==0 oder /cond_stop party (true, wenn party gesetzt und ungleich 0)<II>mak>II<cont_way<II>type>II<mak<II>fileinfo>II<way.tf<II><I>go_way3>I<<II>info>II<Fuehrt den angegebenen Weg aus. Dabei werden die integrierten Sonderbefehle bzw. die eigenen Makros entsprechend beruecksichtigt. Beim Wegablaufen mit Ueberpruefung wird auf die Fehlerausgaben des Muds (?mud_blocking_output) getriggert. Wenn Prefixmakros innerhalb der Wege angegeben sind, werden sie vor jedem Mud-Befehl ausgefuehrt.<II>var>II<fulldetail, way_Trig, last_comm, nextmakro, mud_blocking_output<II>mak>II<bug_way, def_psave_trig, def_psave3_trig<II>type>II<mak<II>fileinfo>II<way.tf<II><I>tri>I<<II>info>II<Definiert einen Regexp-Trigger, der den Weg fortsetzt, wenn er triggert.<II>syn>II</tri regexp<II>ex>II</tri (Ein Schiff kommt an\\.)<II>see>II<wegeingabe, utri, regexp, do_tri, break_tri<II>mak>II<cont_way<II>type>II<mak<II>fileinfo>II<way.tf<II><I>dir_tri>I<<II>info>II<Definiert einen Regexp Trigger, der den Weg fortsetzt, wenn er triggert, und zwar mit dem Richtungsbefehl, dessen Px-Nummer als erster Parameter angegeben wird.<II>ex>II<'/dir_tri 1 Das Schild zeigt nach ([A-Za-z]+), ([A-Za-z]+) und ([A-Za-z]+)'. Dann wird die Richtung, die in der ersten Klammerung steht, als erster Wegebefehl ausgefuehrt.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>do_tri>I<<II>info>II<Fuehrt den vor der '(' uebergebenen Befehl aus und fuehrt den Weg fort, wenn der Trigger innerhalb der Klammern anspringt.<II>syn>II</do_tri befehl(triggertext)<II>see>II<wegeingabe, utri, regexp, tri, break_tri<II>mak>II<cont_way<II>ex>II</do_tri druecke knopf(Der Aufzug kommt an)<II>type>II<mak<II>fileinfo>II<way.tf<II><I>break_tri>I<<II>info>II<Testet, ob einer der Befehle, die nach dem /break_tri und vor dem naechsten /voff kommen, dem Triggertext (regexp) entspricht, und bricht dann den Weg ab; ansonsten wird er fortgesetzt.<II>see>II<wegeingabe, utri, regexp, tri, do_tri, voff<II>syn>II</break_tri triggertext%;befehle%;/voff%;<II>ex>II</break_tri (Ohne Seil kommst Du hier nicht lang)%;kletter nach unten%;/voff%;<II>type>II<mak<II>fileinfo>II<way.tf<II><I>next_prompt>I<<II>info>II<Da nicht alle Befehle, die ans Mud geschickt werden, einen Prompt generieren, diese aber benoetigt, wird um festzustellen, ob ein Teilweg schon abgelaufen wurde, zaehlt dieses Makro den Promptzaehler eins hoeher und setzt dann den Weg fort.<II>see>II<h_action_prompt, cont_way<II>type>II<mak<II>fileinfo>II<way.tf<II><I>utri>I<<II>info>II<Definiert einen Regexp-Trigger, der den Weg fortsetzt, wenn er triggert. Dieser Trigger macht zuerst ein %mud_look_command, um ggf. schon im Raum befindliche Dinge festzustellen. Daher ist es am besten, den Trigger mit einer zweiteiligen rexexp zu versehen.<II>syn>II</utri regexp<II>ex>II</utri (Ein Schiff\\.|Ein Schiff kommt an\\.)<II>see>II<wegeingabe, tri, regxexp<II>type>II<mak<II>fileinfo>II<way.tf<II><I>bug_way>I<<II>info>II<Wird ausgefuehrt, falls bei der ueberprueften Wegausfuehrung ein Fehler aufgetreten ist.@{N}Wenn verify=1 ist, wird gefragt, ob der Weg zwischen dem letzten und dem naechsten Knoten temporaer gesperrt werden soll. Es wird versucht, den Rueckweg zum letzten bekannten Knoten zu berechnen. Dieser kann dann mit /back zurueckgegangen werden. Ansonsten muss das Hindernis beseitigt werden und dann kann mit /c[ontinue] der Weg fortgesetzt werden.@{N}Ist verify==2, dann wird nur das Monster geknuddelt, das im Weg steht, und nach der Beseitigung ;) wird mit /c[ontinue] weitergegangen.<II>var>II<verify, fulldetail, real_way, temp_way, go_way3_param, online<II>mak>II<disable, vorwaerts<II>version>II<1.01<II>type>II<mak<II>fileinfo>II<way.tf<II><I>sperren>I<<II>info>II<Wegstuecken koennen temporaer gesperrt werden. Das kann von Hand mittels /disable erfolgen, oder wenn bei der Ausfuehrung eines Weges ein Fehler auftrat.<II>see>II<disable, enable, verify<II>type>II<see<II>fileinfo>II<way.tf<II><I>disabled>I<<II>info>II<Diese Liste enthaelt die temporaer (wird nicht gespeichert) gesperrten Wegstuecke in der Form Anfangsknoten_Endknoten.@{N}Der dazugehoerige Befehl testet, ob die angegebenen Wegstuecken gesperrt sind.<II>see>II<enable, disable, go, sperren<II>syn>II<$(/disabled Knoten1 Knoten2)<II>return>II<ueber /echo - 0 bei nicht gesperrt, ansonsten 1<II>type>II<mak<II>fileinfo>II<way.tf<II><I>disable>I<<II>info>II<Damit werden Wegstuecke temporaer gesperrt.<II>syn>II</disable Anfangsknoten Endknoten<II>see>II<enable, go, disabled, sperren<II>list>II<disabled<II>type>II<comm<II>fileinfo>II<way.tf<II><I>cache>I<<II>info>II<Der Wegecache speichert die bisher gelaufenen Wege, so dass sie kein zweites Mal berechnet werden muessen. Dabei werden alle Bedingungen (Para/Normalwelt und die Bedingungen im Weg) mit den zur Berechnung aktuellen Werten mit im Cache aufgenommen. Wenn kein Weg gefunden wird, der mit den aktuell gueltigen Werten berechnet wurde, wird er neu berechnet, ansonsten aus den Infos im Cache erzeugt.@{N}Der Cache wird beim Ausfuehren von /editway, /delway, /delnode, /addway usw. aktualisiert.<II>see>II<show_cache, remove_from_cache, clear_cache<II>ex>II<hier mal ein Beispiel fuer einen Cacheeintrag:@{N}-- neander_tpv:@{N}start: neander@{N}end: tpv@{N}steps: 35@{N}way: neander:neanderu:tdrachen:tport:tpv@{N}dim: n@{N}allow: (portals==1)&(p_state=/"seher")<II>type>II<misc<II>fileinfo>II<way.tf<II><I>show_cache>I<<II>info>II<Zeigt den Inhalt des Wegecaches sortiert an.<II>see>II<cache, remove_from_cache, clear_cache<II>type>II<mak<II>fileinfo>II<way.tf<II><I>clear_cache>I<<II>info>II<Loescht den Cache mit den Wegen.<II>see>II<cache, remove_from_cache, show_cache<II>type>II<mak<II>fileinfo>II<way.tf<II><I>remove_from_cache>I<<II>info>II<Entfernt alle Wege aus dem Cache, die den angegebenen Knoten oder Teilweg enthalten.<II>ex>II<'/remove_from_cache knotenname' oder '/remove_from_cache knoten1 knoten2'.<II>see>II<cache, clear_cache, show_cache<II>type>II<mak<II>fileinfo>II<way.tf<II><I>enable>I<<II>info>II<Damit werden temporaer gesperrte Wegstuecke wieder freigegeben.<II>syn>II</enable Anfangsknoten Endknoten<II>see>II<disable, go, disabled, sperren<II>list>II<disabled<II>type>II<comm<II>fileinfo>II<way.tf<II><I>showways>I<<II>info>II<Zeigt alle Wege von und zum angegebenen Knoten, oder, wenn keiner angegeben wurde, des aktuellen Knotens an.<II>see>II<showwway<II>type>II<comm<II>fileinfo>II<way.tf<II><I>create_way>I<<II>info>II<Aus der uebergebenen Abfolge der Wegknoten ermittelt diese Funktion den kompletten Weg.<II>var>II<real_way<II>list>II<ways<II>syn>II</create_way Anfangsknoten:knoten1:knoten2:...:Endknoten<II>type>II<mak<II>fileinfo>II<way.tf<II><I>ao>I<<II>info>II<fuegt den zuletzt gegangenen Weg zur Liste der fest gespeicherten Wege hinzu. Dabei wird die Dimension des Weges mit abgefragt.<II>list>II<often<II>see>II<dimensionen<II>type>II<comm<II>fileinfo>II<way.tf<II><I>einschraenkungen>I<<II>info>II<Die Einschraenkungen fuer die Wege sind wie folgt anzugeben:@{N}all - keine Einschraenkungen.@{N}spielername - nur derjenige kann diesen Weg benutzen.@{N}property:wert - diejenigen koennen den Weg benutzen, deren Properties dem angegebenn Wert entsprechen. Dabei reichen die zur Identifikation notwendigen Buchstaben (z.B. lev:10 fuer Level > 10); bei numerischen Properties wird angenommen, dass der Wert der Property groesser als der angegebene sein muss. Ansonsten muessen die Wertangaben mit dem Wert der Property mindestens den Anfangsbuchstaben gemeinsam haben. Also aufpassen mit den Wertangaben.@{N}logischer Ausdruck mit Properties: Dieser wird einfach ausgewertet, alsoalle Properties ausschreiben und bei der Konstruktion aufpassen.<II>ex>II<'lev:10 (level>10)' oder '((p_guild=~"chaos")&(p_guild_level>6))' usw.<II>see>II<properties, wege, mud_properties<II>type>II<see<II>fileinfo>II<way.tf<II><I>allowed>I<<II>info>II<Testet, ob die aktuellen Properties erlauben, diesen Weg zu gehen.<II>return>II<ueber /echo. 1 bei Erfolg und 0 bei Misserfolg.<II>see>II<einschraenkungen<II>type>II<mak<II>fileinfo>II<way.tf<II><I>getali>I<<II>info>II<Liefert das Alias zum Knoten; wenn keins vorhanden ist, dann den Knotennamen selbst.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>getnode>I<<II>info>II<Liefert den Knotennamen zum Alias; wenn kein Alias vorhanden ist, wird der Parameter zurueckgegeben.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>knotenaliase>I<<II>info>II<Fuer die Wegknotennamen, die beim Erstellen der Wege vergeben wurden, koennen im Nachhinein Aliase vergeben werden, je nach persoenlichem Geschmack. Deshalb bitte die Knotennamen eindeutig und verstaendlich vergeben, damit auch ein anderer was damit anfangen kann.@{N}Intern wird trotzdem mit den Knotennamen gearbeitet ;)<II>see>II</setali, Knoten<II>type>II<see<II>fileinfo>II<way.tf<II><I>setali>I<<II>info>II<Erlaubt fuer beliebige Wegeknoten Aliase zu vergeben. Die Liste der Aliase wird sofort im Anschluss abgespeichert.<II>syn>II</setali zeigt alle Aliase an.@{N} '/setali knoten alias' erzeugt das Alias fuer den Knoten.@{N} '/setali alias neues_alias' ueberschreibt das vorhandene Alias.@{N} '/setali alias' loescht das Alias.<II>list>II<nodealias, lastpoints<II>mak>II<forEach, echolist<II>see>II<Knotenaliase<II>type>II<comm<II>fileinfo>II<way.tf<II><I>wegeingabe>I<<II>info>II<Die Wegeingabe muss von einem Knotenpunkt starten, der entweder mit /wo oder mit /lp gesetzt wurde. Es gibt zwei Arten Wege einzugeben:@{N}Mit /weg werden alle Kommandos, die eingegeben werden, im Hin- und (sofern es erkennbar ist) auch im Rueckweg abgespeichert.@{N}Wenn einfach mit dem Ziffernblock durch die Gegend gewandert wird, werden die Schritte auch mitgeloggt. Spezielle Befehle koennen durch die 0-Taste des Ziffernblocks eingegeben werden. Sofern bekannt. wird auch deren Umkehrung im Rueckweg gespeichert, wenn nicht. wird nach einer gefragt. Diese Befehle werden sofort ausgefuehrt. Mit dieser Taste koennen auch die im Weg enthaltenen Makros eingegeben werden.@{N}Wenn man mit dem Weg fertig ist, macht man einfach /end. Sofern man an einem bekannten Knoten steht, wird das erkannt, ansonsten wird man zur Namensverleihung gebeten.@{N}Dann wird der Weg abgespeichert (siehe dort).<II>see>II<weg speichern, weg editieren, weg, end, lp, wo<II>type>II<see<II>fileinfo>II<way.tf<II><I>weg>I<<II>info>II<Speichert ab dem Einschalten @{B}alle@{n} Kommandos im Hin- und (sofern erahnbar) auch im Rueckweg. Ab dem Ausschalten per /weg oder /end dann nicht mehr.<II>syn>II<einschalten mit /weg und ausschalten mit /weg oder /end<II>mak>II<vorwaerts<II>var>II<weg, wegeingabe<II>hook>II<SEND<II>see>II<wege,<II>type>II<comm<II>fileinfo>II<way.tf<II><I>walk>I<<II>info>II<Ein Send-Hook, der auch als Makro aufgerufen werden kann und die Syntax des ?speedwalk versteht. Er fuegt die expandierten Bewegungen den Wegespeichern des Wegesystems hinzu. Das Besondere ist, dass das Trennzeichen ?movement_marker selbst gesetzt werden kann und dass die Befehle als eine Zeile an das Mud gesendet werden. Das Trennzeichen muss auch vor dem ersten Befehl auftauchen, damit nicht beliebige ans Mud gesendete Strings untersucht werden muessen.<II>see>II<shorten, customize.tf<II>ex>II<[/walk ],5o,2n,25 klatsche,ob,schaue<II>syn>II<regexp: (/walk )?(,([0-9]+)?[^0-9,]+)+<II>version>II<1.03<II>list>II<xtramoves<II>var>II<movement_marker<II>changes>II<1.03 Der Hook kommuniziert mit der Mapper Application ?mapper.tf, wenn die Variable ?mapper auf 1 gesetzt ist. Wenn %automapper auf 1 gesetzt ist, werden Bewegungen sofort in neue Ausgaenge umgewandelt.@{N}Der Hook wird jetzt erst in der customize.tf definiert, wenn der 'movement_marker' feststeht, damit unnoetige Sufrufe vermieden werden. Susserdem kommen sich so hoffentlich die verschiedenen Send-Hooks nicht mehr in die Quere.@{N}1.04 * Einbindung des Mappers (?mapper.tf). Die Befehle, die ans Mud gesandt werden, bekommt auch der Mapper, sofern (%mapper==1). Wenn (%automapper==1) werden dem Mapper zuvor die Befehle zum Erzeugen der Ausgaenge uebermittelt.@{N}* Bug beim Speichern des Rueckweges behoben.<II>type>II<comm<II>fileinfo>II<way.tf<II><I>h_move>I<<II>info>II<Ueberprueft alle Eingaben auf Richtungsbefehle und speichert diese ab.Wenn die Wegaufzeichnung eingeschaltet wurde, werden _alle_ Eingaben abgespeichert. Natuerlich wird auch der Rueckweg gleich mit erzeugt.<II>mak>II<vorwaerts<II>var>II<weg, wegeingabe<II>list>II<xtramoves<II>hook>II<SEND<II>changes>II<1.03 unterstuetzt die Mapper Application (siehe ?walk).@{N}1.04 Einbindung des Mappers (?mapper.tf). Die Befehle, die ans Mud gesandt werden, bekommt auch der Mapper, sofern (%mapper==1). Wenn (%automapper==1) werden dem Mapper zuvor die Befehle zum Erzeugen der Ausgaenge uebermittelt.<II>version>II<1.04<II>see>II<wege, hooks<II>type>II<hook<II>fileinfo>II<way.tf<II><I>vorwaerts>I<<II>info>II<Speichert den angegebenen Wegebefehl im Hinweg. Wenn 'verify' eingeschaltet ist, passiert das nur bei erfolgreicher Ausfuehrung des Befehls. Wenn online eingeschaltet ist, wird der Befehl sofort ausgefuehrt, ansonsten nicht. @{N}Wenn der Rueckbefehl bekannt ist, wird er im Rueckweg gespeichert. Dabei kann ggf. nachgefragt werden. Wenn der Rueckbefehl nicht bekannt ist, wird nachgefragt. Wenn ein '+' vor dem Befehl steht, wird versucht, ihn und auch den Rueckbefehl zu expandieren ('soob' wird zu 'suedostoben' etc.).<II>see>II<online, verify, rueckwaerts, wegeingabe<II>syn>II</vorwaerts [+]befehle<II>type>II<comm<II>fileinfo>II<way.tf<II><I>expand_comm>I<<II>info>II<Liefert den Wert, der in der Liste 'comm_abbr' zum Parameter steht, ansonsten den Parameter selbst.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>addnode>I<<II>info>II<Ersetzt alle vorhandenen Knotenbeschreibungen durch die des aktuellen Raumes. Wenn der zusaetzliche Parameter Zeilenzahl angegeben wird, wird nur die gewuenschte Anzahl Zeilen gespeichert. Ansonsten wird die Variabel ?addlines beachtet. Wenn die Zeilenzahl 0 ist, wird die komplette Raumbeschreibung bis zu den Ausgaengen gespeichert.<II>see>II<knoten, appendnode, delnode<II>var>II<lastpoint, addlines<II>mak>II<getnode, getali<II>syn>II</addnode [knoten [zeilenzahl]]<II>type>II<comm<II>fileinfo>II<way.tf<II><I>appendnode>I<<II>info>II<Fuegt eine @{B}zusaetzliche@{n} Knotenbeschreibung fuer den aktuellen Raum zur Liste hinzu. Wenn der zusaetzliche Parameter Zeilenzahl angegeben wird, wird nur die gewuenschte Anzahl Zeilen gespeichert. Ansonsten wird die Variabel ?addlines beachtet. Wenn die Zeilenzahl 0 ist, wird die komplette Raumbeschreibung bis zu den Ausgaengen gespeichert.<II>see>II<knoten, addnode, delnode<II>var>II<lastpoint, addlines<II>mak>II<getnode, getali<II>syn>II</appendnode [knoten [zeilenzahl]]<II>type>II<comm<II>fileinfo>II<way.tf<II><I>delnode>I<<II>info>II<Loescht den Knoten mit all seinen Wegen (mit Abfrage).@{N}Vor dem Loeschen werden die Wegelisten neu geladen, um Inkonsistenzen zu vermeiden.<II>see>II<addnode, appendnode, knoten<II>var>II<lastpoint<II>mak>II<getnode, getali, delallkeysandvalues, delway<II>list>II<lastpoints<II>syn>II</delnode [knoten]<II>type>II<comm<II>fileinfo>II<way.tf<II><I>addpoint>I<<II>info>II<Liest die aktuelle Raumbeschreibung ein, begrenzt sie bis einschliesslich der Ausgaenge und speichert sie in %fulldetail.<II>var>II<%fulldetail, %getpoint_trig<II>type>II<mak<II>fileinfo>II<way.tf<II><I>restricttoexit>I<<II>info>II<Begrenzt die Raumbeschreibung, die in %fulldetail steht, auf bis einschliesslich der Ausgaenge. Die Variable %room_npcs wird auf den Rest gesetzt.<II>var>II<mud_exits_output<II>type>II<mak<II>fileinfo>II<way.tf<II><I>wo_raum>I<<II>info>II<Zeigt die Raummeldung an, die das letzte, /wo, /end, /wgo, /addnode verarbeitet hat<II>type>II<comm<II>fileinfo>II<way.tf<II><I>wo>I<<II>info>II<Erkennt, welcher Knoten der aktuelle Raum ist.<II>syn>II</wo<II>see>II<knoten, knotenaliase<II>type>II<comm<II>fileinfo>II<way.tf<II><I>getpoint>I<<II>info>II<Vergleicht die aktuelle Raumbeschreibung mit der Liste 'lastpoints' und liefert ggf. den entsprechenden Raum.<II>var>II<%getpoint_trig<II>type>II<mak<II>fileinfo>II<way.tf<II><I>getpoint_trig>I<<II>info>II<Die Nummer des Triggers, der beim Grabben der Raumbeschreibung von ?/getpoint verwendet wird.@{N}Durch "-E(!trig_is_active(getpoint_trig))" lassen sich andere Trigger fuer die Zeit des Grabbens abschalten.<II>see>II</getpoint<II>type>II<var<II>fileinfo>II<way.tf<II><I>addallpoints>I<<II>info>II<Fuegt fuer alle Knoten des Wegesystems eine Erkennung hinzug (mit Abfrage).<II>type>II<comm<II>fileinfo>II<way.tf<II><I>shownode>I<<II>info>II<Zeigt Knoten an.<II>see>II<wege, knoten<II>syn>II<'/shownode *' zeigt alle Knoten an. (Dauert ein bisschen.)@{N}'/shownode knoten' zeigt die Beschreibung fuer den Knoten an.@{N}'/shownode' zeigt die Beschreibung fuer den aktuellen Knoten an.<II>var>II<nodelist (Speicher fuer Knotenliste)<II>changes>II<3.11.99 /shownode arbeitet jetzt auch mit Wildcards, d.h. '/shownode t*' zeigt alle Knoten, an die mit 't' beginnen (Gross/Kleinschreibung egal).<II>type>II<comm<II>fileinfo>II<way.tf<II><I>comparelastpoints>I<<II>info>II<Vergleicht die Raumbeschreibungen in der Liste und zeigt Knoten mit denselben Raumbeschreibungen an.<II>type>II<comm<II>fileinfo>II<way.tf<II><I>shorten2>I<<II>info>II<Uebergibt den uebergebenen Weg ueber die Variable %shorten an /shorten und liefert dessen Ergebnis zurueck.<II>mak>II<shorten<II>type>II<mak<II>fileinfo>II<way.tf<II><I>shorten>I<<II>info>II<Wandelt den uebergebenen Weg aus dem Format 'o%;w%;w%;gehe nach oben%;s%;s%;s%;' in ',o,2w,gehe nach oben,3s' um. Dieses kann mit /walk oder direkt ueber den Sendhook genutzt werden.<II>syn>II</shorten variablenname<II>type>II<mak<II>fileinfo>II<way.tf<II><I>gobk>I<<II>info>II<Geht bis zum letzten bekannten Knoten zurueck, sofern ab diesem nur Richtungsbefehle verwendet wurden.<II>see>II<go, wegeingabe<II>type>II<comm<II>fileinfo>II<way.tf<II><I>end>I<<II>info>II<Beendet die Wegeingabe. Wenn der aktuelle Raum als Knoten erkannt wird, wird er sofort als Endknoten benutzt, ansonsten muss einer eingeben werden. Dann speichert es den Weg ab. Dabei wird gefragt, ob das mit Defaultwerten (s)chnell, mit vorherigem (e)ditieren oder (n)icht geschehen soll. (Nach Aenderunen in tf geht das direkte Editieren nicht mehr, der Weg muss erst mit (s)chnell gespeichert werden und dann mit /editway editiert werden.)@{N}Fuer das Editieren bitte dort nachsehen.@{N}Die Wege werden @{B}sofort@{N} auf die Platte gespeichert.@{N}Falls der Knoten neu ist, wird seine Beschreibung auch erfasst. Dabei wird die ggf. angegebene Zeilenzahl fuer die Speicherung benutzt, ansonsten die Variable ?addlines<II>see>II<wege editieren, einschraenkungen<II>list>II<ways, fromidx, toidx<II>syn>II</end [endknoten [zeilenzahl]]<II>type>II<comm<II>fileinfo>II<way.tf<II><I>reverseway>I<<II>info>II<Kehrt den angegebenen Weg um und speichert ihn ab.<II>syn>II</reverseway (knoten1|*) (knoten2|*)<II>type>II<comm<II>fileinfo>II<way.tf<II><I>addway>I<<II>info>II<Fuegt den als Parameter uebergebenen Weg mit Standardparametern (b all laenge) zur Wegeliste hinzu. Der Weg kann dann mit /editway editiert werden.<II>type>II<info<II>fileinfo>II<way.tf<II><I>loadways>I<<II>info>II<Laedt die Wegelisten neu, besonders vor Aenderungen wegen der Konsistenz zu empfehlen.<II>type>II<mak<II>fileinfo>II<way.tf<II><I>saveways>I<<II>info>II<Speichert die Wegelisten (z.B. nach Aenderungen) ab (wegen der Konsistenz).<II>type>II<info<II>fileinfo>II<way.tf<II><I>editieren>I<<II>info>II<Beim Editieren von Wegen wird nach folgenden Angaben gefragt:@{N}Weg selbst, kann editiert werden, muss danach aber ausfuehrbar sein ;)@{N}Gueltigkeitsbereich: ue(b)erall, nur (n)ormalwelt, nur (p)arawelt (0-9).Parawelt.@{N}Einschraenkungen: all-keine, der Rest siehe Einschraenkungen.@{N}Laenge des Weges: = Gewicht beim Berechnen, also bei langwierigen Wegen hochsetzen.<II>see>II<einschraenkungen, dimension, editway, showway, delway<II>type>II<see<II>fileinfo>II<way.tf<II><I>splitway>I<<II>info>II<Splittet einen Weg in zwei Teilwege auf. Dafuer wird die Anzahl der zum ersten Weg gehoerenden Befehle als Parameter uebergeben und kann dann auch spaeter interaktiv veraendert werden. Es wird nach dem neuen Zwischenknoten gefragt, dann werden die neuen Wege gespeichert und das Loeschen des alten Weges abgefragt.<II>see>II<editway, showway<II>ex>II</splitway knoten1 knoten2 anzahl_befehle_in_erstem_teilweg@{N}z.B. /splitway haus kneipe 5<II>type>II<comm<II>fileinfo>II<way.tf<II><I>editway>I<<II>info>II<Editieren von Wegen (mit jeweiliger Abfrage).<II>syn>II<'/editway * knoten' editiert alle Wege an, die zum Knoten hinfuehren.@{N}'/editway knoten *' editiert alle Wege an, die vom Knoten wegfuehren.@{N}'/editway knoten1 knoten2' editiert den Weg zwischen den Knoten an.<II>see>II<wege editieren, showway, delway, einschraenkungen<II>type>II<comm<II>fileinfo>II<way.tf<II><I>showway>I<<II>info>II<Zeigt Wege an.<II>syn>II<'/showway * knoten' zeigt alle Wege an, die zum Knoten hinfuehren.@{N}'/showway knoten *' zeigt alle Wege an, die vom Knoten wegfuehren.@{N}'/showway knoten1 knoten2' zeigt den Weg zwischen den Knoten an.<II>see>II<wege editieren, editway, delway<II>type>II<comm<II>fileinfo>II<way.tf<II><I>delway>I<<II>info>II<Loescht Wege (mit jeweiliger Abfrage).<II>syn>II<'/delway * knoten' loescht alle Wege an, die zum Knoten hinfuehren.@{N}'/delway knoten *' loescht alle Wege an, die vom Knoten wegfuehren.@{N}'/delway knoten1 knoten2 loescht' den Weg zwischen den Knoten an.<II>see>II<wege editieren, showway, editway<II>type>II<comm<II>fileinfo>II<way.tf<II><I>foreachway>I<<II>info>II<Fuehrt fuer alle Wege, die den Parametern entsprechen, das Makro in \%nextmakro aus mit den Wegeknoten als Parameter.<II>ex>II</set nextmakro /echo von %1 zu %2%;@{N}/forEachWay * gilde%;@{N}/addh syn /forEachWay knoten1|* knoten2|*<II>type>II<mak<II>fileinfo>II<way.tf<II><I>renamenode>I<<II>info>II<Benennt den angegebenen Knoten um.<II>syn>II</renamenode knoten neuername<II>list>II<lastpoints, ways, fromidx, toidx, often, disabled, tanken, often2<II>type>II<comm<II>fileinfo>II<way.tf<II><I>rush>I<<II>info>II</rush erlaubt es, lange unverzweigte Wege schnell abzulaufen. Es erwartet als Parameter eine Startrichtung und beginnt, in diese Richtung zu laufen. Dabei wird jeweils der Ausgang benutzt, mit dem man weiterkommt und nicht zurueck.@{N}/rush stoppt, wenn es einen Fehler bemerkt (z.B. blockender NPC) und schickt dann ggf. dem Mapper einen Befehl rueckwaerts, damit dieser wieder auf dem aktuellen Knoten steht. Ausserdem wird noch angehalten, wenn eine Verzweigung gefunden wird, oder der Weg in einer Sackgasse endet.@{N}Wenn man dem Mapper auf 'automapping' stellt, wird die Bewegung mitgezeichnet.<II>ex>II</rush n<II>type>II<comm<II>fileinfo>II<way.tf<II><I>delnodeinfo>I<<II>info>II<Loescht Zusatzinformationen ueber einen Knoten, wenn keiner angegeben wird, werden die Infos zum aktuellen Knoten geloescht<II>syn>II</delnodeinfo [knoten]<II>type>II<comm<II>fileinfo>II<way.tf<II><I>addnodeinfo>I<<II>info>II<Fuegt der Liste mit den Knoteninfos (nodeinfo) den angebebenen Knoten sowie ein Gebiet und einen Infostring hinzu. Die Bedienung erfolgt interaktiv.<II>list>II<nodeinfo<II>type>II<comm<II>fileinfo>II<way.tf<II><I>nodes_geb>I<<II>info>II<Sucht in den Knoteninfomationen alle Knoten, die im angegebenen Gebiet liegen.<II>type>II<comm<II>fileinfo>II<way.tf<II><I>nodes_info>I<<II>info>II<Sucht in den Knoteninfomationen alle Knoten, die im Text den angegebenen String enthalten.<II>type>II<comm<II>fileinfo>II<way.tf<II><I>nodes_search>I<<II>info>II<Durchforstet die Liste der Knoteninfos nach Knoten, die in dem uebergebenen Attribut den als Restparameter uebergebenen Substring (ignore case) enthalten.<II>ex>II</nodes_search gebiet Ebene<II>type>II<mak<II>fileinfo>II<way.tf<II><I>way.tf>I<<II>info>II<Diese Datei enthaelt das komplette Wegesystem! Es ist soweit wie moeglich mudunabhaengig (ggf. sind geringe Anpassungen fuer andere Muds notwendig).@{N}Vor Benutzung bitte folgende Hilfe-Punkte lesen: knoten, wege, go, wo. Den Rest dann bei Bedarf.<II>changes>II<1.01 Das Problem mit dem tfread()/read() wurde durch /myread in ?util.tf geloest. Deshalb wurde bug_way zweigeteilt. Falls irgendwo noch das Problem mit dem read() auftritt, bitte Mail an mich.@{N}1.02 Es wird jetzt /shread in den Makros verwendet, das sollte keine Probleme mehr machen.@{N}Die /speedwalk-Syntak wird per Makro und Send-Hook unterstuetzt /walk.@{N}1.03 /walk und /h_move unterstuetzen jetzt den Mapper ?mapper.tf (<a href="map/Mapper.html">siehe auch dort</a>).@{N}1.03 Neues Makro /cond_stop fuer bedingtes Anhalten auf Wegen, einige nicht customizable Fehler rausgenommen.@{N}1.04 * Fehlermeldungen von /go erweitert.@{N}* Ausgabe der durchlaufenen Knoten und bei /wo.@{N}* Prefix-Makros fuer jeden Wegebefehl eines Bereiches (/cond_go).@{N}* Einbindung von Mapper in /h_move, /wo, bzw. bei /go.@{N}* Bei der Nutzung von verify (/von, /npc) in den Wegen ist jetzt bei einem Hindernis sowohl /c[ontinue] (weiterlaufen, nachdem Hindernis beseitigt ist) als auch /back (zurueck zum letzten passierten Knoten) moeglich.@{N}* /addway zum direkten Hinzufuegen eines Weges.@{N}* Wegen der Konsistenz der Listen werden die Wegelisten vor jeder Veraenderung neu geladen und danach wieder gespeichert.@{N}* Fehler in /renamenode (hoffentlich) behoben ,)@{N}1.05 * /gof erlaubt jetzt auch die Angabe des Startknotens (also kein /wo vorher).@{N}* Der Inhalt der Variable %after_go wird jetzt nach dem Ablaufen eines Weges mittels /go ausgefuehrt.@{N}* /para fuer Stroh in /wpara umbenannt.@{N}* Einbindung der Parawelt des Mappers in /wpara und /nopara.@{N}* Neues sehr hilfreiches makro /rush zum schnellen Ablaufen langer, unverzweigter Wege.@{N}1.06 (3.11.99) /shownode arbeitet jetzt auch mit Wildcards.@{N}1.07 (13.12.99) /go ist in /_go umbenannt worden, damit eigene Kreationen das /go ersetzen koennen. Kandidaten dafuer sind '/gof start ziel' oder '/wgo ziel' (testet den Startknoten) (z.B. /def go = /wgo %*%;).@{N}/break_tri bricht einen Weg ab, wenn ein Triggertext anschlaegt.@{N}/do_tri fuehrt einen Befehl aus und fuehrt den Weg dann fort, wenn der Trigger anschlaegt.@{N}1.07 (05.01.00) * /shownode, /nodes_geb und /nodes_info zeigen jetzt auch Aliase richtig an.@{N}* /goto und /gobk optimieren jetzt den Weg (n%;s%; raus), bevor der weg vom letzten Knoten wiederholt bzw. zum letzten Knoten zurueckgegangen wird.@{N}* An den Grenzen der Teilwege gibt es eine Optimierung (n%;s%; raus).<II>req>II<loading.tf, lists.tf, util.tf, help.tf, in dem Verzeichnis ${world_host}: xtramoves.list.tf, comm_abbr.list.tf, customize.tf, way.list.tf, fromidx.list.tf, toidx.list.tf, lastpoints.list.tf, [nodealias.list.tf]<II>tut>II<Detaillierte Bedienungsanleitung: siehe auch ?wege.@{N}Siehe auch ?wegeingabe.@{N}Wenn man sich mit Kommandos durch die Gegend bewegt, die in der Liste xtramoves stehen (es sind schon die meisten Richtungskommandos drin), wird der Hin- und Rueckweg mitgeloggt. _Wenn_ man den Weg zurueckgehen koennen will, oder den Weg (ohne editieren) abspeichern will, dann muss man die wegespezifischen Sachen (Spezialkommandos) extra eingeben. Dazu einfach die Taste "0"  auf dem Ziffernblock druecken oder selber "/vorwaerts" eintippen.@{N}Es kommt dann: /vorwaerts - dahinter einfach den Befehl eintragen, der dann sofort ausgefuehrt wird und ggf. (bei komplexen Sachen) kommt danach noch ein /rueckwaerts (eventuell mit Vorgabe). Wenn im Weg bei /rueckwaerts oder /vorwaerts nichts kommen soll, dann einfach Enter druecken.@{N}Wenn man einen Weg speichern will, tippt man einfach an dem Punkt, wo er enden soll, "/end Name" ein und dann wird der Weg von letztem Punkt zu Name gespeichert; Wenn der Endpunkt schon bekannt ist, reicht auch /end. Noch ein paar Fragen beantworten ... fertig.@{N}In den Wegen koennen auch noch witzige Makros enthalten sein (siehe ?wegmakros).@{N}Zum Wegebearbeiten exisiteren folgende Kommandos:@{N}Mit "/delway" kann man einen Weg aus der Wegeliste loeschen. Es erfolgt eine Abfrage und die Wegeliste wird abgespeichert!!!@{N}Mit "/showway from to" kann man sich einen Weg from -> to anzeigen lassen (als Wildcard ist einmal * erlaubt, also alle Wege von/zu einem Punkt).@{N}Mit "/editway" kann man Wege nachtraeglich editieren.@{N}Knotenkommandos: siehe auch ?knoten@{N}"/shownode name" oder "/shownode *" zeigt die Beschreibungen fuer den Knoten oder eine Liste aller Knoten an.@{N}"/addnode [name]" ersetzt alle vorhandenen Beschreibungen fuer den aktuellen oder angegebenen Knoten durch die aktuelle Raumbeschreibung.@{N}"/appendnode [name]" fuegt die Raumbeschreibung der Liste hinzu.@{N}"/delnode [name]" loescht den Knoten und alle Wege, die zu ihm hin- oder von ihm wegfuehren.@{N}"/wo" stellt den aktuellen Knoten fest und zeigt ihn an.@{N}"/setali" vergibt Aliase fuer Knotennamen (die etwas laenger sein koennen).@{N}<II>info>II<addway, saveways<II>misc>II<cache<II>see>II<ways, knoten, wege, portale, dimensionen, wegmakros, sperren, einschraenkungen, knotenaliase, wegeingabe, editieren<II>comm>II<lp, wayindex, askway, gof, ago, wgo, bgo, go, noport, port, wpara, nopara, testway, continue, disable, enable, showways, ao, setali, weg, walk, vorwaerts, addnode, appendnode, delnode, wo_raum, wo, addallpoints, shownode, comparelastpoints, gobk, end, reverseway, splitway, editway, showway, delway, renamenode, rush, delnodeinfo, addnodeinfo, nodes_geb, nodes_info<II>mak>II<~addway, ~getway, lp2, sort_idx_list, initfind, find5, find6, testcon, killlongerways, getshortestway, count_steps, go_way, cont_way, klp, lwo, npc, von, voff, cw, wait, cond_go, no_cond_go, stop, cond_stop, go_way3, tri, dir_tri, do_tri, break_tri, next_prompt, utri, bug_way, disabled, show_cache, clear_cache, remove_from_cache, create_way, allowed, getali, getnode, expand_comm, addpoint, restricttoexit, getpoint, shorten2, shorten, loadways, foreachway, nodes_search<II>hook>II<h_move<II>var>II<alitype, movement_marker, mapper_port, after_go, getpoint_trig<II>cfg>II<wo_show_bug<II>version>II<way.tf,v 1.28 2002/03/27 01:41:50 mh14 (Mesirii@mg.mud.de)<II>req>II<!lists.tf util.sfunc.tf util.prompts.tf util.hooks.tf util.trigger.tf(1.18)<II>type>II<fileinfo<II>fileinfo>II<way.tf<II><I>bs_teilemit_von>I<<II>info>II<Ausgabe der empfangenen Mitteilungen<II>type>II<cfg<II>fileinfo>II<crypt.tf<II><I>bs_teilemit_an>I<<II>info>II<Ausgabe der gesendeten Mitteilungen<II>type>II<cfg<II>fileinfo>II<crypt.tf<II><I>mud_properties>I<<II>info>II<Ausgabe der gesendeten Mitteilungen<II>type>II<cfg<II>info>II<Eine Liste der Properties vom MG.<II>var>II<p_lp, p_mp, p_maxlp, p_maxmp, p_m_lp, p_m_mp, p_escape, p_whimpie, p_name, p_race, p_align, p_tall, p_level, p_weight, p_guild, p_guild_level, p_ep, p_ap, p_maxap, base_dex, mod_dex, dex, base_int, mod_int, int, base_str, mod_str, str, base_const, mod_const, const, p_deaf, p_blind, p_frog<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>p_m_lp>I<<II>info>II<Letze Aenderung der Lebenspunkte.<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>p_m_mp>I<<II>info>II<Letze Aenderung der Magiepunkte.<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>p_update_time>I<<II>info>II<Zeit der letzten Ueberpruefung der Punkte.<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>p_blind>I<<II>info>II<Blind oder nicht blind?<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>p_deaf>I<<II>info>II<Taub oder nicht taub?<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>p_block>I<<II>info>II<ZusatzMP sind was feines :)<II>type>II<var<II>fileinfo>II<mg_properties.tf<II><I>t_lpmp>I<<II>info>II<Faengt die LP/MP-Meldung ab, setzt die Properties p_lp und p_mp und die Differenz p_m_lp und p_m_mp und ruft dann den Hook points auf.<II>var>II<p_mp, p_lp, p_m_lp, p_m_mp<II>type>II<trig<II>fileinfo>II<mg_properties.tf<II><I>echo_hit_points>I<<II>info>II<Berechnet Aenderung der Lebens- und Magiepunkte. Wenn die Aenderung groesser als 1 ist oder man sich im Kampf befindet: Anzeige.@{N}Wenn _pf gesetzt ist und keine Kontrolle-Zaubern laeuft und keine Sperrzeit bis zum naechsten Zauberspruch vorhanden ist, dann wird /pfunc mit ?p_lp und ?p_mp aufgerufen.<II>var>II<p_mp, p_lp, p_m_lp, p_m_mp,<II>type>II<mak<II>fileinfo>II<mg_properties.tf<II><I>updateplayer>I<<II>info>II<Aktualisiert die Spielerinformationen aus dem 'info'-Befehl. Das ist notwendig, um die Einschraenkungen bei den Wegen umzusetzen und um das spielerabhaengige und gildenabhaengige Makrofile zu laden. Bitte ausfuehren, wenn sich an den Properties was aendert.@{N}Der letzte Trigger muss dann updatePlayer2 aufrufen.<II>see>II<properties, einschraenkungen, dateisystem<II>type>II<comm<II>fileinfo>II<mg_properties.tf<II><I>mg_properties.tf>I<<II>comm>II<updateplayer<II>mak>II<echo_hit_points<II>trig>II<t_lpmp<II>var>II<mud_properties, p_m_lp, p_m_mp, p_update_time, p_blind, p_deaf, p_block<II>version>II<mg_properties.tf,v 1.27 2002/03/27 01:21:13 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf util.tf util.hooks.tf util.trigger.tf util.sfunc.tf status.tf(1.19)<II>info>II<Auslesen der Spielerproperties mittels catch-trigger und Liste<II>type>II<fileinfo<II>fileinfo>II<mg_properties.tf<II><I>settank>I<<II>info>II<Dieses Makro dient zum Hinzufuegen und Editieren einer Tanke zu einem Knoten. Es wird ohne Parameter aufgerufen, alle Groessen werden abgefragt.@{N}1. Zuerst wird der Knoten eingegeben. Wenn dieser in der Liste %pubs noch nicht vorhanden ist, wird er hinzugefuegt.@{N}2. Danach wird ein Bezeichner fuer die Tanke abgefragt. Wenn dieser noch nicht vorhanden ist, wird er neu erzeugt, ansonsten editiert@.{N}3. Im folgenden werden die Groessen, die die Tanke bestimmten abgefragt, Lebenspunkte, Magiepunkte, Kosten (Muenzen), Anzahl (bei Kneipe 0), Zeit bis zum Erhalt der Tanke, Zeit bis zum kompletten Auftanken, Art der Tanke (g Getraenk, ag alkoholisches Getraenk, s Speise), Fuellung in % Getraenk, Alk, Speise.@{N}4. Als letztes wird entweder der Name der Tanke (Kneipe) eingegeben oder eine durch vorangestellten _ (Unterstrich) markierte Anzahl von TF- bzw. Mudbefehlen, die zum Tanken ausgefuehrt wird.<II>list>II<pubs<II>type>II<comm<II>fileinfo>II<uselists.tf<II><I>gotank_back>I<<II>info>II<Mit /gotank kann man das Tanken etwas beschleunigen. Man gibt als Parameter einfach den Zielknoten an, fuer den in der Liste 'pubs' (siehe /pub_init bzw. /settank) ein Eintrag vorhanden ist. Wenn man schon an einem Knoten steht, der eine Tanke enthaelt, kann man auch den Parameter weglassen, um sofort zu tanken. Wenn man sich vom letzten Knoten wegbewegt hat, wird das /go zum Zielknoten nur vorgeschlagen, ansonsten wird es automatisch ausgefuehrt. Durch Nutzung der Variablen %after_go (siehe /go) wird nach dem Ablaufen des Weges das Tanken ausgefuehrt. Falls fuer den Zielknoten mehr als ein Eintrag vorhanden ist, gibt es eine Auswahlliste. Und danach geht es zurueck zum Ausgangsknoten.<II>ex>II</gotank_back ziel [nach_tank_ziel|none|autmatisch akt. knoten] [auswahlnr] [(M|L)zielwert (uebertanken)]<II>type>II<comm<II>fileinfo>II<uselists.tf<II><I>pub_init>I<<II>info>II<Mit diesem Makro werden die in einer Kneipe verfuegbaren Speisen und Getraenke erfasst. Falls die Kneipe schon in der Liste %pubs vorhanden ist, wird sie ueberschrieben. Der Name der Kneipe wird in %pubs_name gespeichert. Sie werden temporaer zur Weiterverarbeitung in der Liste %pub_temp_list gespeichert. Nachdem das Menue ausgelesen wurde, wird /init_pub2 fuer Aufraeumungsarbeiten aufgerufen.<II>see>II<settank, gotank, init_pub2, pubs_name<II>ex>II</pub_init Kneipenname, z.B. /pub_init Kchaos<II>type>II<comm<II>fileinfo>II<uselists.tf<II><I>init_pub2>I<<II>info>II<Loescht den Trigger zum Erfassen des Inhalts des Menues und fuegt die Liste %pub_temp_list unter dem Namen %pubs_name zur Liste %pubs_hinzu.<II>type>II<mak<II>fileinfo>II<uselists.tf<II><I>pub_extract>I<<II>info>II<Extrahiert aus den uebergebenen Parametern die Variablen %pub_kosten, %pub_art und %pub_name.<II>type>II<mak<II>fileinfo>II<uselists.tf<II><I>pub_test>I<<II>info>II<Startet den Test eines ausgewaehlten Getraenks bzw einer ausgewaehlten Speise. Zuerst werden alle Speisen angezeigt.<II>ex>II<"/pub_test [Kneipenname]" Wenn nichts angegeben wird, wird die %pub_temp_list der zuletzt initialisierten Kneipe genommen.<II>see>II<pub_init<II>mak>II<pub_extract<II>type>II<comm<II>fileinfo>II<uselists.tf<II><I>pub_kaufe>I<<II>info>II<Startet das Testen einer gewaehlten Speise bzw. eines Getraenks. Dabei werden die Zeit bis zum Erhalt gestoppt und die aktuellen LP und MP gesichert. Die Weiterverarbeitung erfolgt durch /pub_got nach Erhalt der Tanke.<II>see>II<pub_init, pub_test<II>var>II<pub_name, pub_lp, pub_mp<II>mak>II<pub_got<II>type>II<comm<II>fileinfo>II<uselists.tf<II><I>pub_got>I<<II>info>II<Speichert die Zeit bis zum Erhalt der Speise in der Variablen %pub_zbringe. Der Timer wird zurueckgesetzt und es wird eine Ueberwachung der LP/MP eingerichtet (mit /add_to_hook points).@{N}Zur Ueberwachung wird das Makro /pub_count genutzt.@{N}Durch den Zaehler %pub_count wird die Anzahl der Aenderungen unter 2 gezaehlt.<II>var>II<pub_zbringe, pub_count<II>see>II</timer, /add_to_hooks, /pub_count<II>type>II<mak<II>fileinfo>II<uselists.tf<II><I>pub_count>I<<II>info>II<Dieses Makro ueberwacht die Veraenderung der LP/MP. Wenn die Steigerung zweimal (in %pub_count) oder oefter weniger als 2 LP/MP betraegt, wird der Test der Tanke mittels /pub_done beendet.@{N}Die Zeit des Volltankens werden in %pub_ztanken gespeichert und die erhaltenen LP/MP in %pub_temp_lp bzw. %pub_temp_mp.<II>var>II<p_m_mp, p_m_lp, pub_count, pub_ztanken, pub_temp_lp, pub_temp_mp<II>see>II</pub_done, /pub_got, /pub_kaufe, /pub_test, /pub_init<II>type>II<mak<II>fileinfo>II<uselists.tf<II><I>pub_done>I<<II>info>II<Die gesammelten Daten werden nach Abfrage in die Liste 'pubs' geschrieben. Das Makro /pub_count wird aus dem Hook 'points' entfernt.@{N}Die erhaltenen Lebenspunkte/Magiepunkte werden in %pub_lp bzw. %pub_mp gespeichert.@{N}Die erhaltenen Daten werden angezeigt und nach Abfrage in der Liste 'pubs' gespeichert.<II>var>II<pubs, pub_temp_list, pub_nr, pubs_name<II>type>II<mak<II>fileinfo>II<uselists.tf<II><I>uselists.tf>I<<II>info>II<Viele Anwendungsbeispiele fuer die key-value Listen ;))<II>comm>II<settank, gotank_back, pub_init, pub_test, pub_kaufe<II>mak>II<init_pub2, pub_extract, pub_got, pub_count, pub_done<II>version>II<uselists.tf,v 1.5 2001/10/07 18:29:53 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf util.tf<II>type>II<fileinfo<II>fileinfo>II<uselists.tf<II><I>comm_echo_colors>I<<II>info>II<Variable, die die Farben fuer die Kommunikation enthaelt. Fuer jede der drei Kommunikationsarten (sagen/fragen/fluestern, teile mit, frufe) gibt es zwei Farben: eine fuer Mitteilungen an Dich und eine fuer Mitteilungen von Dir an andere. Die Farben stehen in der Reihenfolge@{N}@{}  sag_von_Dir   sag_an_Dich@{N}@{}  tm_von_Dir    tm_an_Dich@{N}@{}  frufe_von_Dir frufe_an_Dich@{N}@{}  special_tm_von_Dir special_tm_an_Dich@{N}Special tm's sind z.b. gecryptete tm's. Diese werden durch ein anders Zeichen als einen : als Trenner im Triggertext gekennzeichnet.@{N}Es werden der Gespraechspartner und die Kommunikationsart eingefaerbt, wobei der Name des Gespraechspartners zusaetzlich noch das Attribut fett erhaelt.@{N}Mit dieser Variable kann (und sollte) jeder in comm.cfg die Farben so setzen, wie es seinen persoenlichen Vorlieben entspricht.<II>ex>II<Die Einstellung@{N}@{}  /set comm_echo_colors=Ccyan uCcyan Cmagenta Cbgmagenta Cgreen uCgreen Cred Cbgred@{N}fuehrt zu Ausgaben wie@{N}@{BCcyan}Du@{nCcyan} sagst:@{n} Hier ist ein Fehler.@{N}@{BuCcyan}Mesirii@{nuCcyan} fragt @{B}Dich@{nuCcyan}:@{n} Wo?@{N}@{BCcyan}Du@{nCcyan} fluesterst @{B}dem Sandtiger@{nCcyan} zu:@{n} Lusche@{N}@{Cmagenta}An @{B}Jof@{nCmagenta}:@{n} Du idelst ja.@{N}@{Cbgmagenta}Von @{B}Dotz@{nCbgmagenta}:@{n} Wo ist die Ewige Schokolade?@{N}@{Cgreen}An @{B}Freunde@{nCgreen}: Huhu.@{N}@{uCgreen}Von Freund @{B}Elberet@{nuCgreen}:@{n} Muh!@{N}@{Cred}Von @{B}Mesirii@{nCred}:@{n} Muh!<II>see>II</comm_t_sagt, /comm_t_fragt, /comm_t_fluestert, /comm_t_teilemit, /comm_t_teilemit2<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_ebenen_list>I<<II>info>II<Enthaelt die Farben fuer die Ebenen (Spezialitaet des MorgenGrauen mg.mud.de). Jeder Listeneintrag hat drei Teile:@{N}1. Ebenenname (muss kleingeschrieben sein)@{N}2. Farbe fuer die eckigen Klammern '[' und ']'@{N}3. Farbe fuer den Namen der Ebene (incl. ':')@{N}Ausser den normalen Ebenennamen gibt es noch einige Sonderfaelle:@{N}- DEFAULT: Falls kein passender Ebenenname in der Liste steht, werden die Farben des DEFAULT-Eintrags genommen.@{N}- team: Etliche Spieler setzen sich als Presay "[Team: ...]". Dies kann hiermit eingefaerbt werden, ebenso die Kommunikation innerhalb eines Teams.@{N}- bezug, autor: Artikelheader der MPA.@{N}Diese Liste kann (und sollte) jederzeit nach persoenlichen Vorlieben geaendert bzw. ergaenzt werden.<II>ex>II<Das Kommando@{N}@{}  /comm_add_ebene beileid BCgreen Ccyan@{N}fuehrt zu Ausgaben wie@{N}@{BCgreen}[@{nCcyan}Beileid:@{n}Dotz isst vor Kummer ein Stueck Schokolade.@{nBCgreen}]@{n}<II>see>II</comm_add_ebene, /comm_t_ebene<II>type>II<list<II>fileinfo>II<comm.tf<II><I>comm_add_ebene>I<<II>info>II<Fuegt zur Liste ?comm_ebenen_list einen Eintrag hinzu. Falls die Liste noch nicht vorhanden war, wird sie erzeugt.<II>syn>II</comm_add_ebene ebenenname Farbe1 Farbe1<II>see>II<comm_ebene_list<II>list>II<comm_ebenen_list<II>type>II<comm<II>fileinfo>II<comm.tf<II><I>comm_ebenen_window>I<<II>info>II<Legt fest, ob das Geschehen auf den Ebenen im Logfenster und Logfile erscheinen soll. Die Bedeutung entspricht dem ersten Parameter von ?/comm_write:@{N}0: Text erscheint weder im Logfenster noch im Logfile;@{N}1: Text erscheint im Logfenster und Logfile;@{N}2: wie 1, jedoch werden vorher Attributdefinitionen entfernt.<II>see>II</comm_t_ebene, /comm_write<II>type>II<var<II>fileinfo>II<comm.tf<II><I>set_comm_name>I<<II>info>II<Setzt ?%comm_window_name auf den richtigen Wert: Existiert im MUD-Verzeichnis ein Player-Verzeichnis (z.B. mg.mud.de/Dotz), so wird <mud-name>/<player-name>/comm.log (also z.B. mg.mud.de/Dotz/comm.log) als Logfile verwendet, andernfalls <mud-name>/comm.log.@{N}(Der erste Fall entspricht also den Optionen "-c -p" von ?/custom, der zweite Fall "-c".)<II>var>II<%comm_window_name, %load_dir<II>func>II<dir_exists<II>mak>II</custom<II>see>II</comm_write, /custom<II>type>II<mak<II>fileinfo>II<comm.tf<II><I>comm_write>I<<II>info>II<Gibt den als zweiten Parameter uebergebenen Text aus und loggt ihn mit, falls der erste Parameter nicht 0 ist.@{N}Ist der erste Parameter 1, so werden die Attributdefinitionen des Textes nicht ins Logfile %comm_window_name uebernommen.<II>syn>II</comm_write 0|1|2 text<II>see>II</comm_t_sagt, /comm_t_fragt, /comm_t_fluestert, /comm_t_teilemit, /comm_t_teilemit2, /remove_attributes, /write_to_window, /set_comm_window<II>var>II<%comm_window_name<II>mak>II</remove_attributes, /write_to_window<II>type>II<mak<II>fileinfo>II<comm.tf<II><I>comm_write_ebene>I<<II>info>II<Wie ?/comm_write, jedoch fuer %comm_ebene_window_name.<II>var>II<comm_ebene_window_name<II>mak>II</comm_write_to_window, /remove_attributes<II>type>II<mak<II>fileinfo>II<comm.tf<II><I>comm_t_fragt>I<<II>info>II<Trigger, der das "frage" abfaengt, es einfaerbt und an ?/comm_write uebergibt.@{N}Wird nicht ausgefuehrt, falls das Wegesystem den aktuellen Standort herausfinden will.<II>see>II</comm_write, %comm_echo_colors<II>mak>II</comm_write, /comm_printable_attributes<II>var>II<%comm_echo_colors, %getpoint_trig<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_t_sagt>I<<II>info>II<Trigger, der das "sage" abfaengt, es einfaerbt und an ?/comm_write uebergibt.@{N}Wird nicht ausgefuehrt, falls das Wegesystem den aktuellen Standort herausfinden will.<II>see>II</comm_write, %comm_echo_colors<II>mak>II</comm_write, /comm_printable_attributes<II>var>II<%comm_echo_colors, %getpoint_trig<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_t_fluestert>I<<II>info>II<Trigger, der das "fluester" abfaengt, es einfaerbt und an ?/comm_write uebergibt.@{N}Wird nicht ausgefuehrt, falls das Wegesystem den aktuellen Standort herausfinden will.<II>see>II</comm_write, %comm_echo_colors<II>mak>II</comm_write, /comm_printable_attributes<II>var>II<%comm_echo_colors, %getpoint_trig<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_last_teilemit>I<<II>info>II<Variable, die den Zeitpunkt des letzten "teile mit" oder "frufe" an Dich enthaelt.<II>see>II</comm_t_teilemit, %comm_beep_teilemit<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_beep_teilemit>I<<II>info>II<Falls einem zum ersten Mal nach %beep_teilemit Sekunden wieder etwas per "teile mit" oder "frufe" mitgeteilt wird, wird ein "/beep 1" ausgefuehrt. Ein Wert von 0 bedeutet, dass kein Pieps ausgegeben werden soll.<II>see>II</comm_t_teilemit, %comm_last_teilemit<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_t_teilemit>I<<II>info>II<Trigger, der das "teile mit" und "frufe" an Dich abfaengt, einfaerbt und an ?/comm_write uebergibt. Wenn der Zeitpunkt des letzten "teile mit" bzw. "frufe" laenger als %beep_teilemit Sekunden her ist, wird ein "/beep 1" ausgefuehrt, sofern %beep_teilemit nicht 0 ist.@{N}Behandelt auch special tm's d.h. Trenner ungleich ":".@{N}Wird nicht ausgefuehrt, falls das Wegesystem den aktuellen Standort herausfinden will.<II>see>II</comm_write, %comm_echo_colors, %comm_last_teilemit, %comm_beep_teilemit<II>var>II<%comm_echo_colors, %comm_last_teilemit, %comm_beep_teilemit, %getpoint_trig<II>mak>II</comm_write, /comm_printable_attributes<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_t_teilemit2>I<<II>info>II<Trigger, der das eigene "teile mit" und "frufe" abfaengt, eingefaerbt und an ?/comm_write uebergibt.@{N}Behandelt auch special tm's d.h. Trenner ungleic ":".@{N}Wird nicht ausgefuehrt, falls das Wegesystem den aktuellen Standort herausfinden will.<II>see>II</comm_write, /comm_echo_colors<II>mak>II</comm_write, /comm_printable_attributes<II>var>II<%comm_echo_colors, %getpoint_trig<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_an_matrix>I<<II>info>II<Trigger zum Abfangen der Matrixmitteleilungen von Dir.<II>comm>II</comm_format_ebene, /comm_write_ebene<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_von_matrix>I<<II>info>II<Trigger zum Abfangen der Matrixmitteleilungen an Dich.<II>comm>II</comm_format_ebene, /comm_write_ebene<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_t_ebene>I<<II>info>II<Dieser Trigger faengt die Meldungen der Ebenen ab.@{N}Wird nicht ausgefuehrt, falls das Wegesystem den aktuellen Standort herausfinden will.<II>see>II<comm_ebenen_list, /comm_add_ebene<II>var>II<%getpoint_trig, %comm_ebenen_window<II>mak>II</comm_format_ebene, /comm_write_ebene<II>type>II<trig<II>fileinfo>II<comm.tf<II><I>comm_non_living>I<<II>info>II<Dieses Makro ist fuer das Einfaerben der Ebenen- und Matrixmeldungen zustaendig.  Die Farben koennen fuer jede Ebene mit dem Kommando ?/comm_add_ebene gesetzt werden. Genaures steht in der Hilfe zu ?comm_ebenen_list. Das Makro benoetigt folgende Informationen in folgenden Variablen:@{N}%comm_ebene: Name der Ebene bzw. Matrix@{N}%comm_ebene_speaker: Wer hat etwas von sich gegeben?@{N}%comm_ebene_bracket: ']' bzw. '' (bei emote)@{N}%comm_ebene_text: Die eigentliche Nachricht (incl. fuehrendem Leerzeichen).<II>see>II</comm_t_ebene, /comm_an_matrix, /comm_von_matrix<II>mak>II</comm_printable_attributes<II>list>II<%comm_ebenen_list<II>info>II<Enthaelt die Liste der NPCs, die einem bisher etwas mitgeteilt haben (durch '~' getrennt, da in NPC-Namen auch Leerzeichen auftreten koennen).  Muss mit '~' anfangen und enden.<II>see>II</comm_check_living, /comm_update_living, %comm_living<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_living>I<<II>info>II<Enthaelt die Liste der Spieler, die anwesend waren, waehrend einem etwas mitgeteilt wurde (durch '~' getrennt). Muss mit '~' anfangen und enden.<II>see>II</comm_check_living, /comm_update_living, %comm_non_living<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_check_living>I<<II>info>II<Ueberprueft durch Scan der Variablen ?%comm_living und ?%comm_non_living, ob der als Parameter uebergebene Name Spieler oder NPC ist und gibt entsprechend 1 oder 0 zurueck. Faengt der Name mit "der ", "die ", "das ", "ein " oder "eine " an, wird ebenfalls 0 fuer NPC zurueckgegeben. Konnte auf diese Weise nicht entschieden werden, ob sich um einen Spieler oder NPC handelt, wird 2 zurueckgegeben und die Liste %comm_living der aktiven Spieler mittels ?/comm_update_living mit der %?comm_living verschmolzen. Ein etwas verzoegerter zweiter Aufruf (das Ergebnis von %mud_short_who muss abgefangen und verarbeitet werden) von /comm_check_living mit dem gleichen Parameter sollte dann entweder 0 oder 1 zurueckgeben. Gross- und Kleinschreibung ist dabei egal, weil das MG dies leider inkonsequent handhabt.<II>see>II</comm_update_living<II>ex>II</let lives=$[comm_check_living("Dotz")]<II>var>II<%comm_living, %comm_non_living, %comm_last_partner, %comm_last_partner_living<II>mak>II</comm_update_living, /comm_check_living2<II>type>II<mak<II>fileinfo>II<comm.tf<II><I>comm_update_living>I<<II>info>II<Startet das %mud_short_who Kommando im Mud und grabbt dessen Ergebnis. Dieses wird dann in ?%comm_living integriert. Es wird aufgerufen, wenn der Kommunikationspartner weder in ?%comm_living noch in ?%comm_non_living auftaucht und nicht mir "Der ", "Die ", "Das ", "Ein" oder "Eine " anfaengt.@{N}Damit das %mud_short_who Kommando nicht stoert, waehrend man sich im Editor befindet, sollte man ein '!' davorsetzen.<II>var>II<%comm_living, %comm_non_living, %fulldetail, %nextmakro, %comm_trig_number<II>see>II</comm_check_living, %mud_short_who<II>mak>II</trig_grab, /tokenize, /update_living2<II>func>II<trig_is_active<II>type>II<mak<II>fileinfo>II<comm.tf<II><I>comm_trig_number>I<<II>info>II<Damit bei laengeren Mitteilungen nicht fuer jede Zeile ein %mud_short_who ans Mud gesendet und die Ausgabe gegrabbt wird, steht in %comm_trig_number die Nummer des letzten Grab-Triggers. Damit kann getestet werden, ob das Grabben bereits beendet wurde oder nicht.<II>see>II</comm_update_living, /trig_is_active, /trig_grab<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_last_partner>I<<II>info>II<Enthaelt den letzten Kommunikationspartner.<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_last_partner_living>I<<II>info>II<Ist 0, falls ?%comm_last_partner ein NPC ist, sonst 1. Falls dies nicht festgestellt werden konnte, ist der Wert 2.@{N}/addh see %comm_last_partner<II>type>II<var<II>fileinfo>II<comm.tf<II><I>comm_tm*>I<<II>info>II<Listet die Mitteilungen des als Parameter angegebenen Spielers (wenn keiner angegeben, dann alle) der letzten halben Stunde oder der angegebenen Zeit auf.<II>syn>II</comm_tm* [spieler [zeit]]<II>ex>II</comm_tm* mesirii 1:00<II>type>II<comm<II>fileinfo>II<comm.tf<II><I>comm_sag*>I<<II>info>II<Listet die "sag" des als Parameter angegebenen Spieler (wenn keiner angegeben, dann alle) der letzten halben Stunde oder der angegebenen Zeit auf.<II>syn>II</comm_sag* [Spieler [zeit]]<II>ex>II</comm_sag* mesirii 1:00<II>type>II<comm<II>fileinfo>II<comm.tf<II><I>comm_p*>I<<II>info>II<Listet jede Zeile, in der der als Parameter angegebene Spieler (wenn keiner angegeben, dann alle) auftaucht, der letzten halben Stunde oder der angegebenen Zeit auf.<II>syn>II</comm_p* [Spieler [zeit]]<II>ex>II</comm_p* mesirii 1:00<II>type>II<comm<II>fileinfo>II<comm.tf<II><I>comm_printable_attributes>I<<II>info>II<Ersetzt im uebergebenen String alle '@' durch '@@@@'. Dies hat zur Folge, dass der String mit "/echo -p" ausgegeben werden kann, ohne dass evtl. vorkommende Attribute interpretiert werden.<II>ex>II<Die Zeile@{N}/echo -p @@{Ccyan}$[comm_printable_attributes("nicht @@{Cred}rot")]@{N}erzeugt als Ausgabe@{N}@{Ccyan}nicht @@{Cred}rot@{n}<II>return>II<String, in dem die Attribute durch "/echo -p" ausgegeben statt interpretiert werden<II>see>II</remove_attributes<II>type>II<func<II>fileinfo>II<comm.tf<II><I>comm_remove>I<<II>info>II<Dieser Befehl entfernt saemtliche Trigger, Makros und Variablen, die von comm.tf genutzt werden.<II>mak>II</remove_packet, /remove_window<II>type>II<comm<II>fileinfo>II<comm.tf<II><I>comm.tf>I<<II>info>II<Enthaelt Befehle, die die Kommunikation mitloggen bzw. vergangene Kommunikation anzeigen. Dabei wird herausgefunden, ob die Kommunikationspartner NPC's sind. In diesem Fall wird die Kommunikation nicht geloggt.@{N}Konfiguration der Farben mittels der Variablen ?%comm_echo_colors und der Liste ?comm_ebenen_list in comm.cfg (siehe jeweilige Hilfe).<II>var>II<%comm_echo_colors, %comm_beep_teilemit, %comm_living, %comm_non_living, %comm_last_partner, %comm_last_partner_living, %comm_window<II>list>II<comm_ebenen_list<II>comm>II</comm_p*, /comm_tm*, /comm_sag*, /comm_remove, /comm_add_ebene<II>trig>II</comm_t_sagt, /comm_t_fragt, /comm_t_fluestert, /comm_t_teilemit, /comm_t_teilemit2, /comm_t_ebene, /comm_an_matrix, /comm_von_matrix<II>func>II</comm_printable_attributes<II>mak>II</comm_write, /comm_write_ebene, /check_living, /update_living, /comm_format_ebene<II>req>II<!help.tf util.tf(1.18) util.sfunc.tf util.trigger.tf(1.11) util.windows.tf lists.tf loading.tf(1.33) util.completion.def, util.echo.tf(1.13)<II>comm>II<comm_add_ebene, comm_tm*, comm_sag*, comm_p*, comm_remove<II>mak>II<set_comm_name, comm_write, comm_write_ebene, comm_check_living, comm_update_living<II>trig>II<comm_t_fragt, comm_t_sagt, comm_t_fluestert, comm_t_teilemit, comm_t_teilemit2, comm_an_matrix, comm_von_matrix, comm_t_ebene<II>func>II<comm_printable_attributes<II>var>II<comm_echo_colors, comm_ebenen_window, comm_last_teilemit, comm_beep_teilemit, comm_non_living, comm_living, comm_trig_number, comm_last_partner, comm_last_partner_living<II>list>II<comm_ebenen_list<II>version>II<comm.tf,v 1.36 2002/03/07 15:50:43 nieten (Dotz@mg.mud.de)<II>req>II<!help.tf util.tf(1.18) util.sfunc.tf util.trigger.tf(1.11) util.windows.tf lists.tf loading.tf(1.33) util.completion.def, util.echo.tf(1.13)<II>type>II<fileinfo<II>fileinfo>II<comm.tf<II><I>kampf.tf>I<<II>version>II<kampf.tf,v 1.7 2002/02/10 22:36:40 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf spells.tf weapon.tf mg_properties.tf ari.tf<II>info>II<Kampfrunden, Arinutzung, Spellwaffenspells, Kampf-Hooks<II>type>II<fileinfo<II>fileinfo>II<kampf.tf<II><I>t_whimpie>I<<II>info>II<Trigger, der die Vorsicht und Fluchtrichtung vom Teddy abfaengt und auf Uebereinstimmung mit den im TF gespeicherten Werten ueberprueft. Falls Sie nicht uebereinstimmen, werden sie auf die gespeicherten Werte zurueckgesetzt. (Es soll ja NPCs geben, die sowas tun.)<II>var>II<p_whimpie, p_escape<II>type>II<trig<II>fileinfo>II<vorsicht.tf<II><I>t_vorsicht>I<<II>info>II<Trigger, der auf die Reaktion der Vorsicht im Mud anspringt und neben einer Ausgabe das Makro /testvorsicht ausfuehrt.<II>type>II<trig<II>fileinfo>II<vorsicht.tf<II><I>testvorsicht>I<<II>info>II<Makro, das beim Anspringen der Vorsicht im Mud ausgefuehrt wird. Es testet, ob man grad im Kampf ist (%kampf>0) und ob die aktuellen LP kleiner als die gesetzte Vorsicht sind (%p_lp<=%p_whimpie). Dann wird der Kampfmodus deaktiviert (%kampf=-1) und die Vorsicht im Mud fuer 10 Sekunden auf 0 gesetzt, damit man dem PingPong-Effekt aus dem Weg geht. Anschliessend wird die in %p_escape_tf gespeicherte Fluchtrichtung ausgefuehrt, da die in %p_escape gespeicherte Flucht schon vom Mud ausgefuehrt wurde. (Alles von TF machen zu lassen kann bei LAG toedlich sein.)<II>type>II<mak<II>fileinfo>II<vorsicht.tf<II><I>v>I<<II>info>II<setzt die Variable %p_whimpie auf den angegebenen Parameter und setzt die Vorsicht im MUD. Falls die Vorsicht groesser als Null ist, wird sofort ein Test durchgefuehrt.<II>type>II<comm<II>fileinfo>II<vorsicht.tf<II><I>fl>I<<II>info>II<Damit wird die Fluchtrichtung gesetzt. Der erste Befehl vor dem %; wird als Fluchtrichtung im Mud (%p_escape) benutzt, der Rest fuer die Fluchtrichtung im TF (%p_escape_tf). Dieser zweite Teil kann auch beliebige TF-Befehle enthalten sowie die speedwalk-Syntax (/walk) ,5o,2so nutzen.<II>ex>II</fl o%;no%;ob%;/go haus%;,o,6sw<II>see>II<walk<II>type>II<comm<II>fileinfo>II<vorsicht.tf<II><I>vorsicht.tf>I<<II>info>II<Enthaelt Befehle, Hooks und Trigger, die es erlauben, erstens dem Pingpongeffekt bei der Vorsicht aus dem Weg zu gehen und zweitens die Fluchtrichung beliebig komplex (TF-Befehle und speedwalk (siehe /walk)) zu machen.<II>var>II<p_escape, p_escape_tf, p_whimpie<II>comm>II<v, fl<II>mak>II<testvorsicht<II>trig>II<t_whimpie, t_vorsicht<II>version>II<vorsicht.tf,v 1.12 2002/02/10 22:36:38 mh14 (Dotz@mg.mud.de, Mesirii@mg.mud.de)<II>req>II<lists.tf<II>type>II<fileinfo<II>fileinfo>II<vorsicht.tf<II><I>tf_vorsicht>I<<II>info>II<Variable, die anzeigt, ob TF die Steuerung der Flucht komplett uebernimmt, oder ob auf die Trigger aus dem Mud geachtet wird.<II>type>II<var<II>fileinfo>II<vorsicht.tf<II><I>tf_min_vorsicht>I<<II>info>II<der Wert der im Mud als Vorsicht gesetzt wird, wenn TF die Steuerung der Flucht komplett! uebernimmt<II>type>II<var<II>fileinfo>II<vorsicht.tf<II><I>tf_not_flucht>I<<II>info>II<die Fluchtrichtung, die gesetzt wird, wenn TF die Steuerung der Vorsicht komplett uebernimmt<II>type>II<var<II>fileinfo>II<vorsicht.tf<II><I>vorsicht_null>I<<II>info>II<steuert, ob die Vorsicht beim Fliehen fr 10 Sekunden auf 0 gesetzt wird.<II>see>II<testvorsicht, exec_vorsicht<II>type>II<var<II>fileinfo>II<vorsicht.tf<II><I>fr_vorsicht_null>I<<II>info>II<steuert, ob eine Fluchtrichtung aus mehr als einem Befehl, das Setzen der Vorsicht beim Fliehen fr 10 Sekunden auf 0 aufhebt. Bei Fluchtrichtungen aus nur einem Befehl wird wenn dieses Flag gesetzt ist, trotzdem die Vorsicht auf 0 gesetzt.<II>see>II<testvorsicht, exec_vorsicht<II>type>II<var<II>fileinfo>II<vorsicht.tf<II><I>h_send_v>I<<II>info>II<Hook der statt /v 100 auch v 100 erlaubt<II>type>II<hook<II>fileinfo>II<vorsicht.tf<II><I>h_send_fl>I<<II>info>II<Hook der statt /fl no%;s%;w%;/go home%; auch fl no%;s%;w%;/go home%; erlaubt<II>type>II<hook<II>fileinfo>II<vorsicht.tf<II><I>ari.tf>I<<II>version>II<ari.tf,v 1.6 2002/02/10 22:36:40 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf<II>info>II<Makros fuer Ari (Fernwaffen)<II>type>II<fileinfo<II>fileinfo>II<ari.tf<II><I>chaos_add_demon>I<<II>info>II<fuegt einen Eintrag zur Liste %demon_list_name hinzu (abspeichern nicht vergessen)<II>syn>II</add kuerzel Daemonenname (wie in sprueche)<II>see>II<zauber, b, chaos_get_demon, vd, ld, sd, d, sp, udd, stop, folge, binde, bdt, bd<II>var>II<demon<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>chaos_get_demon>I<<II>info>II<liefert einen Eintrag aus der Liste %demon_list_name zurueck<II>syn>II</chaos_get_demon kuerzel<II>return>II<in value der Daemonenname<II>var>II<demon<II>see>II<zauber, b, chaos_get_demon, vd, ld, sd, d, sp, udd, stop, folge, binde, bdt, bd<II>type>II<mak<II>fileinfo>II<chaos.tf<II><I>vd>I<<II>info>II<ruft verbannen mit dem aktuellen Daemoen auf<II>var>II<demon<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>ld>I<<II>info>II<zeigt den aktuellen Daemon an<II>var>II<demon<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>sd>I<<II>info>II<setzt den aktuellen Daemon<II>var>II<demon, value<II>syn>II</sd kuerzel|daemon<II>list>II<%demon_list_name<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>d>I<<II>info>II<beschwoert den angegebenen Daemonen, und setzt diesen als aktuellen Daemonen (natuerlich nur wenn Bedingungen stimmen (?zauber))<II>var>II<demon<II>list>II<%demon_list_name<II>see>II<zauber, sd, spell_set_and_cast<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>sp>I<<II>info>II<spendiert dem aktuellen Daemonen die angegeben Sachen<II>syn>II</sp Speise|Getraenk Anzahl<II>var>II<demon<II>mak>II<repeat<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>udd>I<<II>info>II<untersucht den aktuellen Daemon<II>var>II<demon<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>folge>I<<II>info>II<stop mit dem aktuellen Daemon<II>comm>II<bd<II>type>II<comm<II>info>II<folge mit dem aktuellen Daemon<II>comm>II<bd<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>binde>I<<II>info>II<zaubert binde mit aktuellem Daemon<II>see>II<zauber<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>b>I<<II>info>II<beschwoert den angegebenen Daemon, und macht sofort /bd folge leise<II>syn>II</b kuerzel<II>list>II<%demon_list_name<II>see>II<zauber<II>comm>II<sd, spell_set_and_cast, bd<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>bdt>I<<II>info>II<befiehlt aktuellem Daemon das gesetzte oder das angegebene Monster zu toeten<II>var>II<demon<II>syn>II</bdt [monster]<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>bd>I<<II>info>II<befiehlt dem aktuellem Daemon den uebergebenen Befehl<II>syn>II</bd Text<II>var>II<demon<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>sprueche>I<<II>info>II<Liste der Zaubersprueche (auch fuer andere Gilden moeglich)<II>syn>II<Listeneintrag zum Kuerzel: haende magiepunkte sperrzeit spruch (mit %variable moeglich)<II>see>II<zauber<II>type>II<list<II>fileinfo>II<chaos.tf<II><I>daemon>I<<II>info>II<Trigger fuer Kontrolle<II>var>II<konrun<II>mak>II<run_kon<II>type>II<trig<II>fileinfo>II<chaos.tf<II><I>run_kon>I<<II>info>II<Laufmakro fuer Kontrolle<II>var>II<konrun, kon<II>mak>II<kontrolle<II>type>II<mak<II>fileinfo>II<chaos.tf<II><I>kontrolle>I<<II>info>II<zaubert Kontrolle, bei Missgluecken nochmal<II>var>II<kon, sperrzeit<II>type>II<mak<II>fileinfo>II<chaos.tf<II><I>kon>I<<II>info>II<Zeigt an, dass Kontrolle ausgeuebt wird<II>type>II<var<II>fileinfo>II<chaos.tf<II><I>konrun>I<<II>info>II<Zeigt an, dass das Zaubern von Kontrolle am Laufen ist<II>type>II<var<II>fileinfo>II<chaos.tf<II><I>test_kon>I<<II>info>II<Kontrolle war erfolgreich<II>var>II<konrun, kon<II>type>II<trig<II>fileinfo>II<chaos.tf<II><I>schutzweg>I<<II>info>II<Markierung von Verschwinden des Schutzes<II>type>II<trig<II>fileinfo>II<chaos.tf<II><I>ng>I<<II>info>II<nimmt etwas und gibt es dem aktuellen Daemonen<II>var>II<demon<II>syn>II</ng Sache<II>type>II<comm<II>fileinfo>II<chaos.tf<II><I>chaos.tf>I<<II>info>II<enthaelt Einstellungen, Listen mit Abkuerzungen, Hilfsmakros fuer die Chaosgilde im MG<II>comm>II<chaos_add_demon, vd, ld, sd, d, sp, udd, stop, folge, binde, b, bdt, bd, ng<II>mak>II<chaos_get_demon, run_kon, kontrolle<II>trig>II<daemon, test_kon, schutzweg<II>var>II<kon, konrun<II>list>II<sprueche<II>version>II<chaos.tf,v 1.3 2002/02/10 22:43:08 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf<II>type>II<fileinfo<II>fileinfo>II<chaos.tf<II><I>user.tf>I<<II>info>II<enthaelt private Einstellungen, Makros, Trigger u.a.<II>version>II<user.tf,v 1.6 2001/12/20 22:38:33 mh14 (Mesirii@mg.mud.de)<II>req>II<lists.tf customize.tf<II>type>II<fileinfo<II>fileinfo>II<user.tf<II><I>erwarte>I<<II>info>II<Traegt einen Grund ein, aus dem ein gewisser Spieler erwartet wird. Ohne Angabe von Parametern werden die anwesenden Erwarteten mit dem zugehoerigen Grund angezeigt. Durch Angabe von - kann ein Spieler wieder aus der Liste geloescht werden.<II>syn>II</erwarte [<name> <grund>|-]<II>ex>II</erwarte olli Der Olli halt :)<II>ex>II</erwarte olli -<II>type>II<mak<II>fileinfo>II<erwarte.tf<II><I>koma_zkompo_long>I<<II>info>II<Setzt die Farbe, mit der die Erwarte-Anzeige eines Spielers angezeigt wird. (wird offlineFarbe nicht angegeben, wird fuer beide Meldungen die onlineFarbe verwendet)<II>syn>II</erwarte_color <Name> <onlineFarbe> <offlineFarbe><II>ex>II</erwarte_color Olli BCmagenta BCcyan<II>info>II<Die Liste 'koma_zkompo_long' enthaelt die Kurzbeschreibungen der Zaubererkomponenten. Ueber sie wird den einzelnen Komponenten eine numerische ID zugewiesen.<II>type>II<list<II>fileinfo>II<koma.tf<II><I>koma_zkompo_short>I<<II>info>II<Die Liste 'koma_zkompo_short' enthaelt Kurztexte, ueber die die Anzahl der Komponenten in ?koma_echo ausgegeben werden kann.<II>type>II<list<II>fileinfo>II<koma.tf<II><I>koma_zkompo_ewig>I<<II>info>II<Die Liste 'koma_zkompo_ewig' enthaelt Zuordnungen der numerischen ID einer ewigen Komponente zu der numerischen ID der jeweiligen normalen Komponente.<II>type>II<list<II>fileinfo>II<koma.tf<II><I>koma_createlists>I<<II>info>II<INTERN. Erzeugt die notwendigen Komponentenlisten und wird bei Bedarf automatisch beim Laden es Pakets ausgefuehrt.<II>list>II<koma_zkompo_long, koma_zkompo_short, koma_zkompo_ewig<II>syn>II</koma_createlists<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>iszkompo>I<<II>info>II<Ueberprueft, ob die uebergebene Kurzbeschreibung zu einer Zaubererkomponente passt. Ist dies der Fall, so wird die numerische ID zurueckgeliefert. Handelt es sich um eine ewige Komponente, so wird die numerische ID der jeweiligen normalen Komponente zurueckgeliefert, und die Variable ?koma_ewig wird auf 1 gesetzt.<II>syn>II</isZKompo p_short<II>ex>II</isZKompo Flaeschchen mit Feuerwasser<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>getcount>I<<II>info>II<INTERN.<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_getlines>I<<II>info>II<INTERN. Definiert den Trigger fuer den Guertelinhalt, und weist den jeweiligen IDs die Anzahlen zu.<II>syn>II</koma_getlines<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma>I<<II>info>II<Mit dieser Funktion wird der Guertelinhalt eines Zauberers in immer dem gleichen Format dargestellt. "ginhalt" des ewigen Guertels liefert zwar etwas aehnliches, nur ist da die Reihenfolge der Komponenten nicht festgelegt.<II>syn>II</koma<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_echo_variable>I<<II>info>II<INTERN. Liefert zu einer uebergebenen KurzID die Anzahl der vorhandenen Komponenten, mit dem jeweiligen Ausgabeformat versehen (?koma_format).<II>see>II<koma_format<II>syn>II</koma_echo_variable kurzid<II>ex>II</koma_echo_variable alk<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_echo>I<<II>info>II<Gibt eine Textzeile aus, in der Vorkommen von KurzIDs durch die entsprechenden Anzahlen ersetzt werden. Die KurzIDs werden dabei von '&' eingeschlossen. Die Ausgabe kann ausserdem rechtsbuendig auf eine gewisse Anzahl von Stellen formatiert werden. Es wird immer der Wert genommen, der bei der letzten Aktualisierung per /koma festgestellt wurde.<II>syn>II</koma_echo formatstring<II>ex>II</koma_echo Feuerwasser: &fw&<II>ex>II</koma_echo Eiswaasser:  &eis:3&<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display_zweig_verwandlung>I<<II>info>II<Gibt die Magisterkomponenten des Zweigs Verwandlung aus.<II>syn>II</koma_display_zweig_verwandlung<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display_zweig_angriff>I<<II>info>II<Gibt die Magisterkomponenten des Zweigs Angriff aus.<II>syn>II</koma_display_zweig_angriff<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display_zweig_illusion>I<<II>info>II<Gibt die Magisterkomponenten des Zweigs Illusion aus.<II>syn>II</koma_display_zweig_illusion<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display_zweig_abwehr>I<<II>info>II<Gibt die Magisterkomponenten des Zweigs Abwehr aus.<II>syn>II</koma_display_zweig_abwehr<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display_zweig_beherrschung>I<<II>info>II<Gibt die Magisterkomponenten des Zweigs Beherrschung aus.<II>syn>II</koma_display_zweig_beherrschung<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display_zweig_>I<<II>info>II<INTERN.<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma_display>I<<II>info>II<Gibt die vorhandenen Komponenten aus, wie sie beim letzten Aufruf von /koma festgestellt wurden.<II>syn>II</koma_display<II>type>II<mak<II>fileinfo>II<koma.tf<II><I>koma.tf>I<<II>info>II<KOMponenten-Anzeige fuer die Zauberergilde im MorgenGrauen (mg.mud.de)@{N}Ueber /koma wird der Guertelinhalt eingelesen und in einer uebersichtlichen, immer gleich aufgebauten Darstellung angezeigt.<II>req>II<lists.tf<II>see>II<koma<II>mak>II<koma_createlists, iszkompo, getcount, koma_getlines, koma, koma_echo_variable, koma_echo, koma_display_zweig_verwandlung, koma_display_zweig_angriff, koma_display_zweig_illusion, koma_display_zweig_abwehr, koma_display_zweig_beherrschung, koma_display_zweig_, koma_display<II>list>II<koma_zkompo_long, koma_zkompo_short, koma_zkompo_ewig<II>version>II<koma.tf,v 1.8 2002/03/07 13:30:05 olm (Olli@mg.mud.de)<II>req>II<lists.tf<II>type>II<fileinfo<II>fileinfo>II<koma.tf<II><I>
